diff --git a/cupy/_core/include/cupy/type_dispatcher.cuh b/cupy/_core/include/cupy/type_dispatcher.cuh
index 8bfeb4a55..327baaff2 100644
--- a/cupy/_core/include/cupy/type_dispatcher.cuh
+++ b/cupy/_core/include/cupy/type_dispatcher.cuh
@@ -26,6 +26,7 @@
 #define CUPY_TYPE_COMPLEX64  11
 #define CUPY_TYPE_COMPLEX128 12
 #define CUPY_TYPE_BOOL       13
+#define CUPY_NUM_TYPES       14  // end of type macros
 
 
 //
@@ -60,4 +61,9 @@ void dtype_dispatcher(int dtype_id, functor_t f, Ts&&... args)
     }
 }
 
+
+template <typename dtype, class functor_t, typename... Ts>
+void dtype_forwarder(functor_t f, Ts&&... args) {
+    return f.template operator()<dtype>(std::forward<Ts>(args)...);
+}
 #endif  // #ifndef INCLUDE_GUARD_CUPY_TYPE_DISPATCHER_H
diff --git a/cupy/cuda/cupy_cub.cu b/cupy/cuda/cupy_cub.cu
index 6ad7a5589..59659b8e9 100644
--- a/cupy/cuda/cupy_cub.cu
+++ b/cupy/cuda/cupy_cub.cu
@@ -1,740 +1,268 @@
-#include "cupy_cub.h"  // need to make atomicAdd visible to CUB templates early
-#include <cupy/type_dispatcher.cuh>
-
-#ifndef CUPY_USE_HIP
-#include <cub/device/device_reduce.cuh>
-#include <cub/device/device_segmented_reduce.cuh>
-#include <cub/device/device_spmv.cuh>
-#include <cub/device/device_scan.cuh>
-#include <cub/device/device_histogram.cuh>
-#include <cub/iterator/counting_input_iterator.cuh>
-#include <cub/iterator/transform_input_iterator.cuh>
-#else
-#include <hipcub/device/device_reduce.hpp>
-#include <hipcub/device/device_segmented_reduce.hpp>
-#include <hipcub/device/device_scan.hpp>
-#include <hipcub/device/device_histogram.hpp>
-#include <rocprim/iterator/counting_iterator.hpp>
-#include <hipcub/iterator/transform_input_iterator.hpp>
-#endif
-
-
-/* ------------------------------------ Minimum boilerplate to support complex numbers ------------------------------------ */
-#ifndef CUPY_USE_HIP
-// - This works only because all data fields in the *Traits struct are not
-//   used in <cub/device/device_reduce.cuh>.
-// - The Max() and Lowest() below are chosen to comply with NumPy's lexical
-//   ordering; note that std::numeric_limits<T> does not support complex
-//   numbers as in general the comparison is ill defined.
-// - DO NOT USE THIS STUB for supporting CUB sorting!!!!!!
-using namespace cub;
-
-template <>
-struct FpLimits<complex<float>>
-{
-    static __host__ __device__ __forceinline__ complex<float> Max() {
-        return (complex<float>(FLT_MAX, FLT_MAX));
-    }
-
-    static __host__ __device__ __forceinline__ complex<float> Lowest() {
-        return (complex<float>(FLT_MAX * float(-1), FLT_MAX * float(-1)));
-    }
-};
-
-template <>
-struct FpLimits<complex<double>>
-{
-    static __host__ __device__ __forceinline__ complex<double> Max() {
-        return (complex<double>(DBL_MAX, DBL_MAX));
-    }
-
-    static __host__ __device__ __forceinline__ complex<double> Lowest() {
-        return (complex<double>(DBL_MAX * double(-1), DBL_MAX * double(-1)));
-    }
-};
+#include <functional>
 
-template <> struct NumericTraits<complex<float>>  : BaseTraits<FLOATING_POINT, true, false, unsigned int, complex<float>> {};
-template <> struct NumericTraits<complex<double>> : BaseTraits<FLOATING_POINT, true, false, unsigned long long, complex<double>> {};
-
-#else
-
-// hipCUB internally uses std::numeric_limits, so we should provide specializations for the complex numbers.
-// Note that there's std::complex, so to avoid name collision we must use the full decoration (thrust::complex)!
-// TODO(leofang): wrap CuPy's thrust namespace with another one (say, cupy::thrust) for safer scope resolution?
-
-namespace std {
-template <>
-class numeric_limits<thrust::complex<float>> {
-  public:
-    static __host__ __device__ thrust::complex<float> max() noexcept {
-        return thrust::complex<float>(std::numeric_limits<float>::max(), std::numeric_limits<float>::max());
-    }
-
-    static __host__ __device__ thrust::complex<float> lowest() noexcept {
-        return thrust::complex<float>(-std::numeric_limits<float>::max(), -std::numeric_limits<float>::max());
-    }
-};
-
-template <>
-class numeric_limits<thrust::complex<double>> {
-  public:
-    static __host__ __device__ thrust::complex<double> max() noexcept {
-        return thrust::complex<double>(std::numeric_limits<double>::max(), std::numeric_limits<double>::max());
-    }
-
-    static __host__ __device__ thrust::complex<double> lowest() noexcept {
-        return thrust::complex<double>(-std::numeric_limits<double>::max(), -std::numeric_limits<double>::max());
-    }
-};
-
-// Copied from https://github.com/ROCmSoftwarePlatform/hipCUB/blob/master-rocm-3.5/hipcub/include/hipcub/backend/rocprim/device/device_reduce.hpp
-// (For some reason the specialization for __half defined in the above file does not work, so we have to go
-// through the same route as we did above for complex numbers.)
-template <>
-class numeric_limits<__half> {
-  public:
-    static __host__ __device__ __half max() noexcept {
-        unsigned short max_half = 0x7bff;
-        __half max_value = *reinterpret_cast<__half*>(&max_half);
-        return max_value;
-    }
-
-    static __host__ __device__ __half lowest() noexcept {
-        unsigned short lowest_half = 0xfbff;
-        __half lowest_value = *reinterpret_cast<__half*>(&lowest_half);
-        return lowest_value;
-    }
-};
-}  // namespace std
-
-using namespace hipcub;
-
-#endif  // ifndef CUPY_USE_HIP
-/* ------------------------------------ end of boilerplate ------------------------------------ */
-
-
-/* ------------------------------------ "Patches" to CUB ------------------------------------
-   This stub is needed because CUB does not have a built-in "prod" operator
-*/
-
-//
-// product functor
-//
-struct _multiply
-{
-    template <typename T>
-    __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
-    {
-        return a * b;
-    }
-};
-
-//
-// arange functor: arange(0, n+1) -> arange(0, n+1, step_size)
-//
-struct _arange
-{
-    private:
-        int step_size;
-
-    public:
-    __host__ __device__ __forceinline__ _arange(int i): step_size(i) {}
-    __host__ __device__ __forceinline__ int operator()(const int &in) const {
-        return step_size * in;
-    }
-};
-
-#ifndef CUPY_USE_HIP
-typedef TransformInputIterator<int, _arange, CountingInputIterator<int>> seg_offset_itr;
-#else
-typedef TransformInputIterator<int, _arange, rocprim::counting_iterator<int>> seg_offset_itr;
-#endif
-
-/*
-   These stubs are needed because CUB does not handle NaNs properly, while NumPy has certain
-   behaviors with which we must comply.
-*/
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-__host__ __device__ __forceinline__ bool half_isnan(const __half& x) {
-#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
-    return __hisnan(x);
-#else
-    // TODO: avoid cast to float
-    return isnan(__half2float(x));
-#endif
-}
-
-__host__ __device__ __forceinline__ bool half_less(const __half& l, const __half& r) {
-#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
-    return l < r;
-#else
-    // TODO: avoid cast to float
-    return __half2float(l) < __half2float(r);
-#endif
-}
-
-__host__ __device__ __forceinline__ bool half_equal(const __half& l, const __half& r) {
-#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
-    return l == r;
-#else
-    // TODO: avoid cast to float
-    return __half2float(l) == __half2float(r);
-#endif
-}
-#endif
-
-//
-// Max()
-//
-
-// specialization for float for handling NaNs
-template <>
-__host__ __device__ __forceinline__ float Max::operator()(const float &a, const float &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? b : a;}
-}
-
-// specialization for double for handling NaNs
-template <>
-__host__ __device__ __forceinline__ double Max::operator()(const double &a, const double &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? b : a;}
-}
-
-// specialization for complex<float> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ complex<float> Max::operator()(const complex<float> &a, const complex<float> &b) const
-{
-    // - TODO(leofang): just call max() here when the bug in cupy/complex.cuh is fixed
-    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
-    // - isnan() and max() are defined in cupy/complex.cuh
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? b : a;}
-}
-
-// specialization for complex<double> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ complex<double> Max::operator()(const complex<double> &a, const complex<double> &b) const
-{
-    // - TODO(leofang): just call max() here when the bug in cupy/complex.cuh is fixed
-    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
-    // - isnan() and max() are defined in cupy/complex.cuh
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? b : a;}
-}
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-// specialization for half for handling NaNs
-template <>
-__host__ __device__ __forceinline__ __half Max::operator()(const __half &a, const __half &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (half_isnan(a)) {return a;}
-    else if (half_isnan(b)) {return b;}
-    else { return half_less(a, b) ? b : a; }
-}
-#endif
-
-//
-// Min()
-//
-
-// specialization for float for handling NaNs
-template <>
-__host__ __device__ __forceinline__ float Min::operator()(const float &a, const float &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? a : b;}
-}
-
-// specialization for double for handling NaNs
-template <>
-__host__ __device__ __forceinline__ double Min::operator()(const double &a, const double &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? a : b;}
-}
-
-// specialization for complex<float> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ complex<float> Min::operator()(const complex<float> &a, const complex<float> &b) const
-{
-    // - TODO(leofang): just call min() here when the bug in cupy/complex.cuh is fixed
-    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
-    // - isnan() and min() are defined in cupy/complex.cuh
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? a : b;}
-}
-
-// specialization for complex<double> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ complex<double> Min::operator()(const complex<double> &a, const complex<double> &b) const
-{
-    // - TODO(leofang): just call min() here when the bug in cupy/complex.cuh is fixed
-    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
-    // - isnan() and min() are defined in cupy/complex.cuh
-    if (isnan(a)) {return a;}
-    else if (isnan(b)) {return b;}
-    else {return a < b ? a : b;}
-}
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-// specialization for half for handling NaNs
-template <>
-__host__ __device__ __forceinline__ __half Min::operator()(const __half &a, const __half &b) const
-{
-    // NumPy behavior: NaN is always chosen!
-    if (half_isnan(a)) {return a;}
-    else if (half_isnan(b)) {return b;}
-    else { return half_less(a, b) ? a : b; }
-}
-#endif
-
-//
-// ArgMax()
-//
-
-// specialization for float for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, float> ArgMax::operator()(
-    const KeyValuePair<int, float> &a,
-    const KeyValuePair<int, float> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for double for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, double> ArgMax::operator()(
-    const KeyValuePair<int, double> &a,
-    const KeyValuePair<int, double> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for complex<float> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, complex<float>> ArgMax::operator()(
-    const KeyValuePair<int, complex<float>> &a,
-    const KeyValuePair<int, complex<float>> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for complex<double> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, complex<double>> ArgMax::operator()(
-    const KeyValuePair<int, complex<double>> &a,
-    const KeyValuePair<int, complex<double>> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-// specialization for half for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, __half> ArgMax::operator()(
-    const KeyValuePair<int, __half> &a,
-    const KeyValuePair<int, __half> &b) const
-{
-    if (half_isnan(a.value))
-        return a;
-    else if (half_isnan(b.value))
-        return b;
-    else if ((half_less(a.value, b.value)) ||
-             (half_equal(a.value, b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-#endif
-
-//
-// ArgMin()
-//
-
-// specialization for float for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, float> ArgMin::operator()(
-    const KeyValuePair<int, float> &a,
-    const KeyValuePair<int, float> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for double for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, double> ArgMin::operator()(
-    const KeyValuePair<int, double> &a,
-    const KeyValuePair<int, double> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for complex<float> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, complex<float>> ArgMin::operator()(
-    const KeyValuePair<int, complex<float>> &a,
-    const KeyValuePair<int, complex<float>> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-// specialization for complex<double> for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, complex<double>> ArgMin::operator()(
-    const KeyValuePair<int, complex<double>> &a,
-    const KeyValuePair<int, complex<double>> &b) const
-{
-    if (isnan(a.value))
-        return a;
-    else if (isnan(b.value))
-        return b;
-    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-}
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-// specialization for half for handling NaNs
-template <>
-__host__ __device__ __forceinline__ KeyValuePair<int, __half> ArgMin::operator()(
-    const KeyValuePair<int, __half> &a,
-    const KeyValuePair<int, __half> &b) const
-{
-    if (half_isnan(a.value))
-        return a;
-    else if (half_isnan(b.value))
-        return b;
-    else if ((half_less(b.value, a.value)) ||
-             (half_equal(a.value, b.value) && (b.key < a.key)))
-        return b;
-    else
-        return a;
-
-}
-#endif
-
-/* ------------------------------------ End of "patches" ------------------------------------ */
-
-//
-// **** CUB Sum ****
-//
-struct _cub_reduce_sum {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        DeviceReduce::Sum(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<T*>(y), num_items, s);
-    }
-};
-
-struct _cub_segmented_reduce_sum {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
-    {
-        DeviceSegmentedReduce::Sum(workspace, workspace_size,
-            static_cast<T*>(x), static_cast<T*>(y), num_segments,
-            offset_start, offset_start+1, s);
-    }
-};
-
-//
-// **** CUB Prod ****
-//
-struct _cub_reduce_prod {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        _multiply product_op;
-        // the init value is cast from 1.0f because on host __half can only be
-        // initialized by float or double; static_cast<__half>(1) = 0 on host.
-        DeviceReduce::Reduce(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<T*>(y), num_items, product_op, static_cast<T>(1.0f), s);
-    }
-};
-
-struct _cub_segmented_reduce_prod {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
-    {
-        _multiply product_op;
-        // the init value is cast from 1.0f because on host __half can only be
-        // initialized by float or double; static_cast<__half>(1) = 0 on host.
-        DeviceSegmentedReduce::Reduce(workspace, workspace_size,
-            static_cast<T*>(x), static_cast<T*>(y), num_segments,
-            offset_start, offset_start+1,
-            product_op, static_cast<T>(1.0f), s);
-    }
-};
-
-//
-// **** CUB Min ****
-//
-struct _cub_reduce_min {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        DeviceReduce::Min(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<T*>(y), num_items, s);
-    }
-};
-
-struct _cub_segmented_reduce_min {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
-    {
-        DeviceSegmentedReduce::Min(workspace, workspace_size,
-            static_cast<T*>(x), static_cast<T*>(y), num_segments,
-            offset_start, offset_start+1, s);
-    }
-};
-
-//
-// **** CUB Max ****
-//
-struct _cub_reduce_max {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        DeviceReduce::Max(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<T*>(y), num_items, s);
-    }
-};
-
-struct _cub_segmented_reduce_max {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
-    {
-        DeviceSegmentedReduce::Max(workspace, workspace_size,
-            static_cast<T*>(x), static_cast<T*>(y), num_segments,
-            offset_start, offset_start+1, s);
-    }
-};
-
-//
-// **** CUB ArgMin ****
-//
-struct _cub_reduce_argmin {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        DeviceReduce::ArgMin(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<KeyValuePair<int, T>*>(y), num_items, s);
-    }
-};
-
-// TODO(leofang): add _cub_segmented_reduce_argmin
-
-//
-// **** CUB ArgMax ****
-//
-struct _cub_reduce_argmax {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
-        int num_items, cudaStream_t s)
-    {
-        DeviceReduce::ArgMax(workspace, workspace_size, static_cast<T*>(x),
-            static_cast<KeyValuePair<int, T>*>(y), num_items, s);
-    }
-};
-
-// TODO(leofang): add _cub_segmented_reduce_argmax
-
-//
-// **** CUB SpMV ****
-//
-struct _cub_device_spmv {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* values,
-        void* row_offsets, void* column_indices, void* x, void* y,
-        int num_rows, int num_cols, int num_nonzeros, cudaStream_t stream)
-    {
-        #ifndef CUPY_USE_HIP
-        DeviceSpmv::CsrMV(workspace, workspace_size, static_cast<T*>(values),
-            static_cast<int*>(row_offsets), static_cast<int*>(column_indices),
-            static_cast<T*>(x), static_cast<T*>(y), num_rows, num_cols,
-            num_nonzeros, stream);
-        #endif
-    }
-};
-
-//
-// **** CUB InclusiveSum  ****
-//
-struct _cub_inclusive_sum {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
-        int num_items, cudaStream_t s)
-    {
-        DeviceScan::InclusiveSum(workspace, workspace_size, static_cast<T*>(input),
-            static_cast<T*>(output), num_items, s);
-    }
-};
-
-//
-// **** CUB inclusive product  ****
-//
-struct _cub_inclusive_product {
-    template <typename T>
-    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
-        int num_items, cudaStream_t s)
-    {
-        _multiply product_op;
-        DeviceScan::InclusiveScan(workspace, workspace_size, static_cast<T*>(input),
-            static_cast<T*>(output), product_op, num_items, s);
-    }
-};
-
-//
-// **** CUB histogram range ****
-//
-struct _cub_histogram_range {
-    template <typename sampleT,
-              typename binT = typename If<std::is_integral<sampleT>::value, double, sampleT>::Type>
-    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
-        int n_bins, void* bins, size_t n_samples, cudaStream_t s) const
-    {
-        // Ugly hack to avoid specializing complex types, which cub::DeviceHistogram does not support.
-        // The If and Equals templates are from cub/util_type.cuh.
-        // TODO(leofang): revisit this part when complex support is added to cupy.histogram()
-        #ifndef CUPY_USE_HIP
-        typedef typename If<(Equals<sampleT, complex<float>>::VALUE || Equals<sampleT, complex<double>>::VALUE),
-                            double,
-                            sampleT>::Type h_sampleT;
-        typedef typename If<(Equals<binT, complex<float>>::VALUE || Equals<binT, complex<double>>::VALUE),
-                            double,
-                            binT>::Type h_binT;
-        #else
-        typedef typename std::conditional<(std::is_same<sampleT, complex<float>>::value || std::is_same<sampleT, complex<double>>::value),
-                                          double,
-                                          sampleT>::type h_sampleT;
-        typedef typename std::conditional<(std::is_same<binT, complex<float>>::value || std::is_same<binT, complex<double>>::value),
-                                          double,
-                                          binT>::type h_binT;
-        #endif
-
-        // TODO(leofang): CUB has a bug that when specializing n_samples with type size_t,
-        // it would error out. Before the fix (thrust/cub#38) is merged we disable the code
-        // path splitting for now. A type/range check must be done in the caller.
-        // TODO(leofang): check if hipCUB has the same bug or not
-
-        // if (n_samples < (1ULL << 31)) {
-            int num_samples = n_samples;
-            DeviceHistogram::HistogramRange(workspace, workspace_size, static_cast<h_sampleT*>(input),
-                #ifndef CUPY_USE_HIP
-                static_cast<long long*>(output), n_bins, static_cast<h_binT*>(bins), num_samples, s);
-                #else
-                // rocPRIM looks up atomic_add() from the namespace rocprim::detail; there's no way we can
-                // inject a "long long" version as we did for CUDA, so we must do it in "unsigned long long"
-                // and convert later...
-                static_cast<unsigned long long*>(output), n_bins, static_cast<h_binT*>(bins), num_samples, s);
-                #endif
-        // } else {
-        //     DeviceHistogram::HistogramRange(workspace, workspace_size, static_cast<h_sampleT*>(input),
-        //         static_cast<long long*>(output), n_bins, static_cast<h_binT*>(bins), n_samples, s);
-        // }
-    }
-};
+#include <cupy/type_dispatcher.cuh>
+#include "cupy_cub.h"  // need to make atomicAdd visible to CUB templates early
+#include "cupy_cub.inl"
+
+
+namespace cupy {
+
+  std::function<cupy::DeviceReduceT> device_reduce_sum_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_sum_CUPY_TYPE_INT8      ,
+    cub_device_reduce_sum_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_sum_CUPY_TYPE_INT16     ,
+    cub_device_reduce_sum_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_sum_CUPY_TYPE_INT32     ,
+    cub_device_reduce_sum_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_sum_CUPY_TYPE_INT64     ,
+    cub_device_reduce_sum_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_sum_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_sum_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_sum_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_sum_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_sum_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_sum_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceReduceT> device_reduce_prod_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_prod_CUPY_TYPE_INT8      ,
+    cub_device_reduce_prod_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_prod_CUPY_TYPE_INT16     ,
+    cub_device_reduce_prod_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_prod_CUPY_TYPE_INT32     ,
+    cub_device_reduce_prod_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_prod_CUPY_TYPE_INT64     ,
+    cub_device_reduce_prod_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_prod_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_prod_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_prod_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_prod_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_prod_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_prod_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceReduceT> device_reduce_min_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_min_CUPY_TYPE_INT8      ,
+    cub_device_reduce_min_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_min_CUPY_TYPE_INT16     ,
+    cub_device_reduce_min_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_min_CUPY_TYPE_INT32     ,
+    cub_device_reduce_min_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_min_CUPY_TYPE_INT64     ,
+    cub_device_reduce_min_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_min_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_min_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_min_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_min_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_min_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_min_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceReduceT> device_reduce_max_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_max_CUPY_TYPE_INT8      ,
+    cub_device_reduce_max_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_max_CUPY_TYPE_INT16     ,
+    cub_device_reduce_max_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_max_CUPY_TYPE_INT32     ,
+    cub_device_reduce_max_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_max_CUPY_TYPE_INT64     ,
+    cub_device_reduce_max_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_max_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_max_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_max_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_max_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_max_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_max_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceReduceT> device_reduce_argmin_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_argmin_CUPY_TYPE_INT8      ,
+    cub_device_reduce_argmin_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_argmin_CUPY_TYPE_INT16     ,
+    cub_device_reduce_argmin_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_argmin_CUPY_TYPE_INT32     ,
+    cub_device_reduce_argmin_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_argmin_CUPY_TYPE_INT64     ,
+    cub_device_reduce_argmin_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_argmin_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_argmin_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_argmin_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_argmin_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceReduceT> device_reduce_argmax_targets[CUPY_NUM_TYPES] = {
+    cub_device_reduce_argmax_CUPY_TYPE_INT8      ,
+    cub_device_reduce_argmax_CUPY_TYPE_UINT8     ,
+    cub_device_reduce_argmax_CUPY_TYPE_INT16     ,
+    cub_device_reduce_argmax_CUPY_TYPE_UINT16    ,
+    cub_device_reduce_argmax_CUPY_TYPE_INT32     ,
+    cub_device_reduce_argmax_CUPY_TYPE_UINT32    ,
+    cub_device_reduce_argmax_CUPY_TYPE_INT64     ,
+    cub_device_reduce_argmax_CUPY_TYPE_UINT64    ,
+    cub_device_reduce_argmax_CUPY_TYPE_FLOAT16   ,
+    cub_device_reduce_argmax_CUPY_TYPE_FLOAT32   ,
+    cub_device_reduce_argmax_CUPY_TYPE_FLOAT64   ,
+    cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64 ,
+    cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128,
+    cub_device_reduce_argmax_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceSegmentedReduceT> device_segmented_reduce_sum_targets[CUPY_NUM_TYPES] = {
+    cub_device_segmented_reduce_sum_CUPY_TYPE_INT8      ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8     ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_INT16     ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16    ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_INT32     ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32    ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_INT64     ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64    ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16   ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32   ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64   ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64 ,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128,
+    cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceSegmentedReduceT> device_segmented_reduce_prod_targets[CUPY_NUM_TYPES] = {
+    cub_device_segmented_reduce_prod_CUPY_TYPE_INT8      ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8     ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_INT16     ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16    ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_INT32     ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32    ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_INT64     ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64    ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16   ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32   ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64   ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64 ,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128,
+    cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceSegmentedReduceT> device_segmented_reduce_min_targets[CUPY_NUM_TYPES] = {
+    cub_device_segmented_reduce_min_CUPY_TYPE_INT8      ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_UINT8     ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_INT16     ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_UINT16    ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_INT32     ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_UINT32    ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_INT64     ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_UINT64    ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16   ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32   ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64   ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64 ,
+    cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128,
+    cub_device_segmented_reduce_min_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceSegmentedReduceT> device_segmented_reduce_max_targets[CUPY_NUM_TYPES] = {
+    cub_device_segmented_reduce_max_CUPY_TYPE_INT8      ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_UINT8     ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_INT16     ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_UINT16    ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_INT32     ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_UINT32    ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_INT64     ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_UINT64    ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16   ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32   ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64   ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64 ,
+    cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128,
+    cub_device_segmented_reduce_max_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceScanT> device_scan_cumsum_targets[CUPY_NUM_TYPES] = {
+    cub_device_scan_cumsum_CUPY_TYPE_INT8      ,
+    cub_device_scan_cumsum_CUPY_TYPE_UINT8     ,
+    cub_device_scan_cumsum_CUPY_TYPE_INT16     ,
+    cub_device_scan_cumsum_CUPY_TYPE_UINT16    ,
+    cub_device_scan_cumsum_CUPY_TYPE_INT32     ,
+    cub_device_scan_cumsum_CUPY_TYPE_UINT32    ,
+    cub_device_scan_cumsum_CUPY_TYPE_INT64     ,
+    cub_device_scan_cumsum_CUPY_TYPE_UINT64    ,
+    cub_device_scan_cumsum_CUPY_TYPE_FLOAT16   ,
+    cub_device_scan_cumsum_CUPY_TYPE_FLOAT32   ,
+    cub_device_scan_cumsum_CUPY_TYPE_FLOAT64   ,
+    cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64 ,
+    cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128,
+    cub_device_scan_cumsum_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceScanT> device_scan_cumprod_targets[CUPY_NUM_TYPES] = {
+    cub_device_scan_cumprod_CUPY_TYPE_INT8      ,
+    cub_device_scan_cumprod_CUPY_TYPE_UINT8     ,
+    cub_device_scan_cumprod_CUPY_TYPE_INT16     ,
+    cub_device_scan_cumprod_CUPY_TYPE_UINT16    ,
+    cub_device_scan_cumprod_CUPY_TYPE_INT32     ,
+    cub_device_scan_cumprod_CUPY_TYPE_UINT32    ,
+    cub_device_scan_cumprod_CUPY_TYPE_INT64     ,
+    cub_device_scan_cumprod_CUPY_TYPE_UINT64    ,
+    cub_device_scan_cumprod_CUPY_TYPE_FLOAT16   ,
+    cub_device_scan_cumprod_CUPY_TYPE_FLOAT32   ,
+    cub_device_scan_cumprod_CUPY_TYPE_FLOAT64   ,
+    cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64 ,
+    cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128,
+    cub_device_scan_cumprod_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceSpmvT> device_spmv_targets[CUPY_NUM_TYPES] = {
+    cub_device_spmv_CUPY_TYPE_INT8      ,
+    cub_device_spmv_CUPY_TYPE_UINT8     ,
+    cub_device_spmv_CUPY_TYPE_INT16     ,
+    cub_device_spmv_CUPY_TYPE_UINT16    ,
+    cub_device_spmv_CUPY_TYPE_INT32     ,
+    cub_device_spmv_CUPY_TYPE_UINT32    ,
+    cub_device_spmv_CUPY_TYPE_INT64     ,
+    cub_device_spmv_CUPY_TYPE_UINT64    ,
+    cub_device_spmv_CUPY_TYPE_FLOAT16   ,
+    cub_device_spmv_CUPY_TYPE_FLOAT32   ,
+    cub_device_spmv_CUPY_TYPE_FLOAT64   ,
+    cub_device_spmv_CUPY_TYPE_COMPLEX128,
+    cub_device_spmv_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceHistRangeT> device_histogram_range_targets[CUPY_NUM_TYPES] = {
+    cub_device_histogram_range_CUPY_TYPE_INT8      ,
+    cub_device_histogram_range_CUPY_TYPE_UINT8     ,
+    cub_device_histogram_range_CUPY_TYPE_INT16     ,
+    cub_device_histogram_range_CUPY_TYPE_UINT16    ,
+    cub_device_histogram_range_CUPY_TYPE_INT32     ,
+    cub_device_histogram_range_CUPY_TYPE_UINT32    ,
+    cub_device_histogram_range_CUPY_TYPE_INT64     ,
+    cub_device_histogram_range_CUPY_TYPE_UINT64    ,
+    cub_device_histogram_range_CUPY_TYPE_FLOAT16   ,
+    cub_device_histogram_range_CUPY_TYPE_FLOAT32   ,
+    cub_device_histogram_range_CUPY_TYPE_FLOAT64   ,
+    nullptr,
+    nullptr,
+    cub_device_histogram_range_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::DeviceHistEvenT> device_histogram_even_targets[CUPY_NUM_TYPES] = {
+    cub_device_histogram_even_CUPY_TYPE_INT8      ,
+    cub_device_histogram_even_CUPY_TYPE_UINT8     ,
+    cub_device_histogram_even_CUPY_TYPE_INT16     ,
+    cub_device_histogram_even_CUPY_TYPE_UINT16    ,
+    cub_device_histogram_even_CUPY_TYPE_INT32     ,
+    cub_device_histogram_even_CUPY_TYPE_UINT32    ,
+    cub_device_histogram_even_CUPY_TYPE_INT64     ,
+    cub_device_histogram_even_CUPY_TYPE_UINT64    ,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    nullptr,
+    cub_device_histogram_even_CUPY_TYPE_BOOL      ,
+  };
+
+}  // namespace cupy
 
-//
-// **** CUB histogram even ****
-//
-struct _cub_histogram_even {
-    template <typename sampleT>
-    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
-        int& n_bins, int& lower, int& upper, size_t n_samples, cudaStream_t s) const
-    {
-        #ifndef CUPY_USE_HIP
-        // Ugly hack to avoid specializing numerical types
-        typedef typename If<std::is_integral<sampleT>::value, sampleT, int>::Type h_sampleT;
-        int num_samples = n_samples;
-        static_assert(sizeof(long long) == sizeof(intptr_t), "not supported");
-        DeviceHistogram::HistogramEven(workspace, workspace_size, static_cast<h_sampleT*>(input),
-            static_cast<long long*>(output), n_bins, lower, upper, num_samples, s);
-        #else
-        throw std::runtime_error("HIP is not supported yet");
-        #endif
-    }
-};
 
 //
 // APIs exposed to CuPy
@@ -746,17 +274,17 @@ void cub_device_reduce(void* workspace, size_t& workspace_size, void* x, void* y
     int num_items, cudaStream_t stream, int op, int dtype_id)
 {
     switch(op) {
-    case CUPY_CUB_SUM:      return dtype_dispatcher(dtype_id, _cub_reduce_sum(),
+    case CUPY_CUB_SUM:      return cupy::device_reduce_sum_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
-    case CUPY_CUB_MIN:      return dtype_dispatcher(dtype_id, _cub_reduce_min(),
+    case CUPY_CUB_PROD:      return cupy::device_reduce_prod_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
-    case CUPY_CUB_MAX:      return dtype_dispatcher(dtype_id, _cub_reduce_max(),
+    case CUPY_CUB_MIN:      return cupy::device_reduce_min_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
-    case CUPY_CUB_ARGMIN:   return dtype_dispatcher(dtype_id, _cub_reduce_argmin(),
+    case CUPY_CUB_MAX:      return cupy::device_reduce_max_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
-    case CUPY_CUB_ARGMAX:   return dtype_dispatcher(dtype_id, _cub_reduce_argmax(),
+    case CUPY_CUB_ARGMIN:      return cupy::device_reduce_argmin_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
-    case CUPY_CUB_PROD:     return dtype_dispatcher(dtype_id, _cub_reduce_prod(),
+    case CUPY_CUB_ARGMAX:      return cupy::device_reduce_argmax_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
     default:            throw std::runtime_error("Unsupported operation");
     }
@@ -777,29 +305,19 @@ void cub_device_segmented_reduce(void* workspace, size_t& workspace_size,
     void* x, void* y, int num_segments, int segment_size,
     cudaStream_t stream, int op, int dtype_id)
 {
-    // CUB internally use int for offset...
-    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
-    #ifndef CUPY_USE_HIP
-    CountingInputIterator<int> count_itr(0);
-    #else
-    rocprim::counting_iterator<int> count_itr(0);
-    #endif
-    _arange scaling(segment_size);
-    seg_offset_itr itr(count_itr, scaling);
-
     switch(op) {
-    case CUPY_CUB_SUM:
-        return dtype_dispatcher(dtype_id, _cub_segmented_reduce_sum(),
-                   workspace, workspace_size, x, y, num_segments, itr, stream);
-    case CUPY_CUB_MIN:
-        return dtype_dispatcher(dtype_id, _cub_segmented_reduce_min(),
-                   workspace, workspace_size, x, y, num_segments, itr, stream);
-    case CUPY_CUB_MAX:
-        return dtype_dispatcher(dtype_id, _cub_segmented_reduce_max(),
-                   workspace, workspace_size, x, y, num_segments, itr, stream);
-    case CUPY_CUB_PROD:
-        return dtype_dispatcher(dtype_id, _cub_segmented_reduce_prod(),
-                   workspace, workspace_size, x, y, num_segments, itr, stream);
+      case CUPY_CUB_SUM:
+          return cupy::device_segmented_reduce_sum_targets[dtype_id](
+                     workspace, workspace_size, x, y, num_segments, segment_size, stream);
+      case CUPY_CUB_PROD:
+          return cupy::device_segmented_reduce_prod_targets[dtype_id](
+                     workspace, workspace_size, x, y, num_segments, segment_size, stream);
+      case CUPY_CUB_MIN:
+          return cupy::device_segmented_reduce_min_targets[dtype_id](
+                     workspace, workspace_size, x, y, num_segments, segment_size, stream);
+      case CUPY_CUB_MAX:
+          return cupy::device_segmented_reduce_max_targets[dtype_id](
+                     workspace, workspace_size, x, y, num_segments, segment_size, stream);
     default:
         throw std::runtime_error("Unsupported operation");
     }
@@ -823,12 +341,9 @@ void cub_device_spmv(void* workspace, size_t& workspace_size, void* values,
     int num_cols, int num_nonzeros, cudaStream_t stream,
     int dtype_id)
 {
-    #ifndef CUPY_USE_HIP
-    return dtype_dispatcher(dtype_id, _cub_device_spmv(),
-                            workspace, workspace_size, values, row_offsets,
-                            column_indices, x, y, num_rows, num_cols,
-                            num_nonzeros, stream);
-    #endif
+    return cupy::device_spmv_targets[dtype_id](
+        workspace, workspace_size, values, row_offsets, column_indices,
+        x, y, num_rows, num_cols, num_nonzeros, stream);
 }
 
 size_t cub_device_spmv_get_workspace_size(void* values, void* row_offsets,
@@ -850,10 +365,10 @@ void cub_device_scan(void* workspace, size_t& workspace_size, void* x, void* y,
 {
     switch(op) {
     case CUPY_CUB_CUMSUM:
-        return dtype_dispatcher(dtype_id, _cub_inclusive_sum(),
+        return cupy::device_scan_cumsum_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
     case CUPY_CUB_CUMPROD:
-        return dtype_dispatcher(dtype_id, _cub_inclusive_product(),
+        return cupy::device_scan_cumprod_targets[dtype_id](
                                 workspace, workspace_size, x, y, num_items, stream);
     default:
         throw std::runtime_error("Unsupported operation");
@@ -880,7 +395,7 @@ void cub_device_histogram_range(void* workspace, size_t& workspace_size, void* x
     }
 
     // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
-    return dtype_dispatcher(dtype_id, _cub_histogram_range(),
+    return cupy::device_histogram_range_targets[dtype_id](
                             workspace, workspace_size, x, y, n_bins, bins, n_samples, stream);
 }
 
@@ -896,10 +411,8 @@ size_t cub_device_histogram_range_get_workspace_size(void* x, void* y, int n_bin
 void cub_device_histogram_even(void* workspace, size_t& workspace_size, void* x, void* y,
     int n_bins, int lower, int upper, size_t n_samples, cudaStream_t stream, int dtype_id)
 {
-    #ifndef CUPY_USE_HIP
-    return dtype_dispatcher(dtype_id, _cub_histogram_even(),
+    return cupy::device_histogram_even_targets[dtype_id](
                             workspace, workspace_size, x, y, n_bins, lower, upper, n_samples, stream);
-    #endif
 }
 
 size_t cub_device_histogram_even_get_workspace_size(void* x, void* y, int n_bins,
diff --git a/cupy/cuda/cupy_cub.inl b/cupy/cuda/cupy_cub.inl
new file mode 100644
index 000000000..df825adad
--- /dev/null
+++ b/cupy/cuda/cupy_cub.inl
@@ -0,0 +1,960 @@
+#include "cupy_cub.h"  // need to make atomicAdd visible to CUB templates early
+#include <cupy/type_dispatcher.cuh>
+
+#ifndef CUPY_USE_HIP
+#include <cub/device/device_reduce.cuh>
+#include <cub/device/device_segmented_reduce.cuh>
+#include <cub/device/device_spmv.cuh>
+#include <cub/device/device_scan.cuh>
+#include <cub/device/device_histogram.cuh>
+#include <cub/iterator/counting_input_iterator.cuh>
+#include <cub/iterator/transform_input_iterator.cuh>
+#else
+#include <hipcub/device/device_reduce.hpp>
+#include <hipcub/device/device_segmented_reduce.hpp>
+#include <hipcub/device/device_scan.hpp>
+#include <hipcub/device/device_histogram.hpp>
+#include <rocprim/iterator/counting_iterator.hpp>
+#include <hipcub/iterator/transform_input_iterator.hpp>
+#endif
+
+
+/* ------------------------------------ Minimum boilerplate to support complex numbers ------------------------------------ */
+#ifndef CUPY_USE_HIP
+// - This works only because all data fields in the *Traits struct are not
+//   used in <cub/device/device_reduce.cuh>.
+// - The Max() and Lowest() below are chosen to comply with NumPy's lexical
+//   ordering; note that std::numeric_limits<T> does not support complex
+//   numbers as in general the comparison is ill defined.
+// - DO NOT USE THIS STUB for supporting CUB sorting!!!!!!
+using namespace cub;
+
+template <>
+struct FpLimits<complex<float>>
+{
+    static __host__ __device__ __forceinline__ complex<float> Max() {
+        return (complex<float>(FLT_MAX, FLT_MAX));
+    }
+
+    static __host__ __device__ __forceinline__ complex<float> Lowest() {
+        return (complex<float>(FLT_MAX * float(-1), FLT_MAX * float(-1)));
+    }
+};
+
+template <>
+struct FpLimits<complex<double>>
+{
+    static __host__ __device__ __forceinline__ complex<double> Max() {
+        return (complex<double>(DBL_MAX, DBL_MAX));
+    }
+
+    static __host__ __device__ __forceinline__ complex<double> Lowest() {
+        return (complex<double>(DBL_MAX * double(-1), DBL_MAX * double(-1)));
+    }
+};
+
+template <> struct NumericTraits<complex<float>>  : BaseTraits<FLOATING_POINT, true, false, unsigned int, complex<float>> {};
+template <> struct NumericTraits<complex<double>> : BaseTraits<FLOATING_POINT, true, false, unsigned long long, complex<double>> {};
+
+#else
+
+// hipCUB internally uses std::numeric_limits, so we should provide specializations for the complex numbers.
+// Note that there's std::complex, so to avoid name collision we must use the full decoration (thrust::complex)!
+// TODO(leofang): wrap CuPy's thrust namespace with another one (say, cupy::thrust) for safer scope resolution?
+
+namespace std {
+template <>
+class numeric_limits<thrust::complex<float>> {
+  public:
+    static __host__ __device__ thrust::complex<float> max() noexcept {
+        return thrust::complex<float>(std::numeric_limits<float>::max(), std::numeric_limits<float>::max());
+    }
+
+    static __host__ __device__ thrust::complex<float> lowest() noexcept {
+        return thrust::complex<float>(-std::numeric_limits<float>::max(), -std::numeric_limits<float>::max());
+    }
+};
+
+template <>
+class numeric_limits<thrust::complex<double>> {
+  public:
+    static __host__ __device__ thrust::complex<double> max() noexcept {
+        return thrust::complex<double>(std::numeric_limits<double>::max(), std::numeric_limits<double>::max());
+    }
+
+    static __host__ __device__ thrust::complex<double> lowest() noexcept {
+        return thrust::complex<double>(-std::numeric_limits<double>::max(), -std::numeric_limits<double>::max());
+    }
+};
+
+// Copied from https://github.com/ROCmSoftwarePlatform/hipCUB/blob/master-rocm-3.5/hipcub/include/hipcub/backend/rocprim/device/device_reduce.hpp
+// (For some reason the specialization for __half defined in the above file does not work, so we have to go
+// through the same route as we did above for complex numbers.)
+template <>
+class numeric_limits<__half> {
+  public:
+    static __host__ __device__ __half max() noexcept {
+        unsigned short max_half = 0x7bff;
+        __half max_value = *reinterpret_cast<__half*>(&max_half);
+        return max_value;
+    }
+
+    static __host__ __device__ __half lowest() noexcept {
+        unsigned short lowest_half = 0xfbff;
+        __half lowest_value = *reinterpret_cast<__half*>(&lowest_half);
+        return lowest_value;
+    }
+};
+}  // namespace std
+
+using namespace hipcub;
+
+#endif  // ifndef CUPY_USE_HIP
+/* ------------------------------------ end of boilerplate ------------------------------------ */
+
+
+/* ------------------------------------ "Patches" to CUB ------------------------------------
+   This stub is needed because CUB does not have a built-in "prod" operator
+*/
+
+//
+// product functor
+//
+struct _multiply
+{
+    template <typename T>
+    __host__ __device__ __forceinline__ T operator()(const T &a, const T &b) const
+    {
+        return a * b;
+    }
+};
+
+//
+// arange functor: arange(0, n+1) -> arange(0, n+1, step_size)
+//
+struct _arange
+{
+    private:
+        int step_size;
+
+    public:
+    __host__ __device__ __forceinline__ _arange(int i): step_size(i) {}
+    __host__ __device__ __forceinline__ int operator()(const int &in) const {
+        return step_size * in;
+    }
+};
+
+#ifndef CUPY_USE_HIP
+typedef TransformInputIterator<int, _arange, CountingInputIterator<int>> seg_offset_itr;
+#else
+typedef TransformInputIterator<int, _arange, rocprim::counting_iterator<int>> seg_offset_itr;
+#endif
+
+/*
+   These stubs are needed because CUB does not handle NaNs properly, while NumPy has certain
+   behaviors with which we must comply.
+*/
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+__host__ __device__ __forceinline__ bool half_isnan(const __half& x) {
+#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
+    return __hisnan(x);
+#else
+    // TODO: avoid cast to float
+    return isnan(__half2float(x));
+#endif
+}
+
+__host__ __device__ __forceinline__ bool half_less(const __half& l, const __half& r) {
+#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
+    return l < r;
+#else
+    // TODO: avoid cast to float
+    return __half2float(l) < __half2float(r);
+#endif
+}
+
+__host__ __device__ __forceinline__ bool half_equal(const __half& l, const __half& r) {
+#if defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__)
+    return l == r;
+#else
+    // TODO: avoid cast to float
+    return __half2float(l) == __half2float(r);
+#endif
+}
+#endif
+
+//
+// Max()
+//
+
+// specialization for float for handling NaNs
+template <>
+__host__ __device__ __forceinline__ float Max::operator()(const float &a, const float &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? b : a;}
+}
+
+// specialization for double for handling NaNs
+template <>
+__host__ __device__ __forceinline__ double Max::operator()(const double &a, const double &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? b : a;}
+}
+
+// specialization for complex<float> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ complex<float> Max::operator()(const complex<float> &a, const complex<float> &b) const
+{
+    // - TODO(leofang): just call max() here when the bug in cupy/complex.cuh is fixed
+    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
+    // - isnan() and max() are defined in cupy/complex.cuh
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? b : a;}
+}
+
+// specialization for complex<double> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ complex<double> Max::operator()(const complex<double> &a, const complex<double> &b) const
+{
+    // - TODO(leofang): just call max() here when the bug in cupy/complex.cuh is fixed
+    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
+    // - isnan() and max() are defined in cupy/complex.cuh
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? b : a;}
+}
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+// specialization for half for handling NaNs
+template <>
+__host__ __device__ __forceinline__ __half Max::operator()(const __half &a, const __half &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (half_isnan(a)) {return a;}
+    else if (half_isnan(b)) {return b;}
+    else { return half_less(a, b) ? b : a; }
+}
+#endif
+
+//
+// Min()
+//
+
+// specialization for float for handling NaNs
+template <>
+__host__ __device__ __forceinline__ float Min::operator()(const float &a, const float &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? a : b;}
+}
+
+// specialization for double for handling NaNs
+template <>
+__host__ __device__ __forceinline__ double Min::operator()(const double &a, const double &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? a : b;}
+}
+
+// specialization for complex<float> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ complex<float> Min::operator()(const complex<float> &a, const complex<float> &b) const
+{
+    // - TODO(leofang): just call min() here when the bug in cupy/complex.cuh is fixed
+    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
+    // - isnan() and min() are defined in cupy/complex.cuh
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? a : b;}
+}
+
+// specialization for complex<double> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ complex<double> Min::operator()(const complex<double> &a, const complex<double> &b) const
+{
+    // - TODO(leofang): just call min() here when the bug in cupy/complex.cuh is fixed
+    // - NumPy behavior: If both a and b contain NaN, the first argument is chosen
+    // - isnan() and min() are defined in cupy/complex.cuh
+    if (isnan(a)) {return a;}
+    else if (isnan(b)) {return b;}
+    else {return a < b ? a : b;}
+}
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+// specialization for half for handling NaNs
+template <>
+__host__ __device__ __forceinline__ __half Min::operator()(const __half &a, const __half &b) const
+{
+    // NumPy behavior: NaN is always chosen!
+    if (half_isnan(a)) {return a;}
+    else if (half_isnan(b)) {return b;}
+    else { return half_less(a, b) ? a : b; }
+}
+#endif
+
+//
+// ArgMax()
+//
+
+// specialization for float for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, float> ArgMax::operator()(
+    const KeyValuePair<int, float> &a,
+    const KeyValuePair<int, float> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for double for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, double> ArgMax::operator()(
+    const KeyValuePair<int, double> &a,
+    const KeyValuePair<int, double> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for complex<float> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, complex<float>> ArgMax::operator()(
+    const KeyValuePair<int, complex<float>> &a,
+    const KeyValuePair<int, complex<float>> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for complex<double> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, complex<double>> ArgMax::operator()(
+    const KeyValuePair<int, complex<double>> &a,
+    const KeyValuePair<int, complex<double>> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value > a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+// specialization for half for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, __half> ArgMax::operator()(
+    const KeyValuePair<int, __half> &a,
+    const KeyValuePair<int, __half> &b) const
+{
+    if (half_isnan(a.value))
+        return a;
+    else if (half_isnan(b.value))
+        return b;
+    else if ((half_less(a.value, b.value)) ||
+             (half_equal(a.value, b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+#endif
+
+//
+// ArgMin()
+//
+
+// specialization for float for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, float> ArgMin::operator()(
+    const KeyValuePair<int, float> &a,
+    const KeyValuePair<int, float> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for double for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, double> ArgMin::operator()(
+    const KeyValuePair<int, double> &a,
+    const KeyValuePair<int, double> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for complex<float> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, complex<float>> ArgMin::operator()(
+    const KeyValuePair<int, complex<float>> &a,
+    const KeyValuePair<int, complex<float>> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+// specialization for complex<double> for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, complex<double>> ArgMin::operator()(
+    const KeyValuePair<int, complex<double>> &a,
+    const KeyValuePair<int, complex<double>> &b) const
+{
+    if (isnan(a.value))
+        return a;
+    else if (isnan(b.value))
+        return b;
+    else if ((b.value < a.value) || ((a.value == b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+}
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+    && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+// specialization for half for handling NaNs
+template <>
+__host__ __device__ __forceinline__ KeyValuePair<int, __half> ArgMin::operator()(
+    const KeyValuePair<int, __half> &a,
+    const KeyValuePair<int, __half> &b) const
+{
+    if (half_isnan(a.value))
+        return a;
+    else if (half_isnan(b.value))
+        return b;
+    else if ((half_less(b.value, a.value)) ||
+             (half_equal(a.value, b.value) && (b.key < a.key)))
+        return b;
+    else
+        return a;
+
+}
+#endif
+
+/* ------------------------------------ End of "patches" ------------------------------------ */
+
+//
+// **** CUB Sum ****
+//
+struct _cub_reduce_sum {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        DeviceReduce::Sum(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<T*>(y), num_items, s);
+    }
+};
+
+struct _cub_segmented_reduce_sum {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
+    {
+        DeviceSegmentedReduce::Sum(workspace, workspace_size,
+            static_cast<T*>(x), static_cast<T*>(y), num_segments,
+            offset_start, offset_start+1, s);
+    }
+};
+
+//
+// **** CUB Prod ****
+//
+struct _cub_reduce_prod {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        _multiply product_op;
+        // the init value is cast from 1.0f because on host __half can only be
+        // initialized by float or double; static_cast<__half>(1) = 0 on host.
+        DeviceReduce::Reduce(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<T*>(y), num_items, product_op, static_cast<T>(1.0f), s);
+    }
+};
+
+struct _cub_segmented_reduce_prod {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
+    {
+        _multiply product_op;
+        // the init value is cast from 1.0f because on host __half can only be
+        // initialized by float or double; static_cast<__half>(1) = 0 on host.
+        DeviceSegmentedReduce::Reduce(workspace, workspace_size,
+            static_cast<T*>(x), static_cast<T*>(y), num_segments,
+            offset_start, offset_start+1,
+            product_op, static_cast<T>(1.0f), s);
+    }
+};
+
+//
+// **** CUB Min ****
+//
+struct _cub_reduce_min {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        DeviceReduce::Min(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<T*>(y), num_items, s);
+    }
+};
+
+struct _cub_segmented_reduce_min {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
+    {
+        DeviceSegmentedReduce::Min(workspace, workspace_size,
+            static_cast<T*>(x), static_cast<T*>(y), num_segments,
+            offset_start, offset_start+1, s);
+    }
+};
+
+//
+// **** CUB Max ****
+//
+struct _cub_reduce_max {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        DeviceReduce::Max(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<T*>(y), num_items, s);
+    }
+};
+
+struct _cub_segmented_reduce_max {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_segments, seg_offset_itr offset_start, cudaStream_t s)
+    {
+        DeviceSegmentedReduce::Max(workspace, workspace_size,
+            static_cast<T*>(x), static_cast<T*>(y), num_segments,
+            offset_start, offset_start+1, s);
+    }
+};
+
+//
+// **** CUB ArgMin ****
+//
+struct _cub_reduce_argmin {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        DeviceReduce::ArgMin(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<KeyValuePair<int, T>*>(y), num_items, s);
+    }
+};
+
+// TODO(leofang): add _cub_segmented_reduce_argmin
+
+//
+// **** CUB ArgMax ****
+//
+struct _cub_reduce_argmax {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* x, void* y,
+        int num_items, cudaStream_t s)
+    {
+        DeviceReduce::ArgMax(workspace, workspace_size, static_cast<T*>(x),
+            static_cast<KeyValuePair<int, T>*>(y), num_items, s);
+    }
+};
+
+// TODO(leofang): add _cub_segmented_reduce_argmax
+
+//
+// **** CUB SpMV ****
+//
+struct _cub_device_spmv {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* values,
+        void* row_offsets, void* column_indices, void* x, void* y,
+        int num_rows, int num_cols, int num_nonzeros, cudaStream_t stream)
+    {
+        #ifndef CUPY_USE_HIP
+        DeviceSpmv::CsrMV(workspace, workspace_size, static_cast<T*>(values),
+            static_cast<int*>(row_offsets), static_cast<int*>(column_indices),
+            static_cast<T*>(x), static_cast<T*>(y), num_rows, num_cols,
+            num_nonzeros, stream);
+        #endif
+    }
+};
+
+//
+// **** CUB InclusiveSum  ****
+//
+struct _cub_inclusive_sum {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
+        int num_items, cudaStream_t s)
+    {
+        DeviceScan::InclusiveSum(workspace, workspace_size, static_cast<T*>(input),
+            static_cast<T*>(output), num_items, s);
+    }
+};
+
+//
+// **** CUB inclusive product  ****
+//
+struct _cub_inclusive_product {
+    template <typename T>
+    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
+        int num_items, cudaStream_t s)
+    {
+        _multiply product_op;
+        DeviceScan::InclusiveScan(workspace, workspace_size, static_cast<T*>(input),
+            static_cast<T*>(output), product_op, num_items, s);
+    }
+};
+
+//
+// **** CUB histogram range ****
+//
+struct _cub_histogram_range {
+    template <typename sampleT,
+              typename binT = typename If<std::is_integral<sampleT>::value, double, sampleT>::Type>
+    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
+        int n_bins, void* bins, size_t n_samples, cudaStream_t s) const
+    {
+        // Note: this function does not support complex types
+        // TODO(leofang): revisit this part when complex support is added to cupy.histogram()
+
+        // TODO(leofang): CUB has a bug that when specializing n_samples with type size_t,
+        // it would error out. Before the fix (thrust/cub#38) is merged we disable the code
+        // path splitting for now. A type/range check must be done in the caller.
+        // TODO(leofang): check if hipCUB has the same bug or not
+
+        // if (n_samples < (1ULL << 31)) {
+            int num_samples = n_samples;
+            DeviceHistogram::HistogramRange(workspace, workspace_size, static_cast<sampleT*>(input),
+                #ifndef CUPY_USE_HIP
+                static_cast<long long*>(output), n_bins, static_cast<binT*>(bins), num_samples, s);
+                #else
+                // rocPRIM looks up atomic_add() from the namespace rocprim::detail; there's no way we can
+                // inject a "long long" version as we did for CUDA, so we must do it in "unsigned long long"
+                // and convert later...
+                static_cast<unsigned long long*>(output), n_bins, static_cast<binT*>(bins), num_samples, s);
+                #endif
+        // } else {
+        //     DeviceHistogram::HistogramRange(workspace, workspace_size, static_cast<h_sampleT*>(input),
+        //         static_cast<long long*>(output), n_bins, static_cast<h_binT*>(bins), n_samples, s);
+        // }
+    }
+};
+
+//
+// **** CUB histogram even ****
+//
+struct _cub_histogram_even {
+    template <typename sampleT>
+    void operator()(void* workspace, size_t& workspace_size, void* input, void* output,
+        int& n_bins, int& lower, int& upper, size_t n_samples, cudaStream_t s) const
+    {
+        // Note: this function does not support non-integer types
+        #ifndef CUPY_USE_HIP
+        int num_samples = n_samples;
+        static_assert(sizeof(long long) == sizeof(intptr_t), "not supported");
+        DeviceHistogram::HistogramEven(workspace, workspace_size, static_cast<sampleT*>(input),
+            static_cast<long long*>(output), n_bins, lower, upper, num_samples, s);
+        #else
+        throw std::runtime_error("HIP is not supported yet");
+        #endif
+    }
+};
+
+
+//
+// Placeholders for storing function pointers to the template specializations
+// Note: no template instatiation should be done in this file!
+//
+
+namespace cupy {
+  using DeviceReduceT = void (void*, size_t&, void*, void*, int, cudaStream_t);
+
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_sum_CUPY_TYPE_BOOL      ;
+
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_prod_CUPY_TYPE_BOOL      ;
+
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_min_CUPY_TYPE_BOOL      ;
+
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_max_CUPY_TYPE_BOOL      ;
+
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_argmin_CUPY_TYPE_BOOL      ;
+
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_INT8      ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_UINT8     ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_INT16     ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_UINT16    ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_INT32     ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_UINT32    ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_INT64     ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_UINT64    ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_FLOAT16   ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_FLOAT32   ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_FLOAT64   ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128;
+  extern DeviceReduceT cub_device_reduce_argmax_CUPY_TYPE_BOOL      ;
+
+  using DeviceSegmentedReduceT = void (void*, size_t&, void*, void*, int, int, cudaStream_t);
+
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_INT8      ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_INT16     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_INT32     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_INT64     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL      ;
+
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_INT8      ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_INT16     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_INT32     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_INT64     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL      ;
+
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_INT8      ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_UINT8     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_INT16     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_UINT16    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_INT32     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_UINT32    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_INT64     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_UINT64    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_min_CUPY_TYPE_BOOL      ;
+
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_INT8      ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_UINT8     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_INT16     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_UINT16    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_INT32     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_UINT32    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_INT64     ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_UINT64    ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64   ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128;
+  extern DeviceSegmentedReduceT cub_device_segmented_reduce_max_CUPY_TYPE_BOOL      ;
+
+  using DeviceScanT = void (void*, size_t&, void*, void*, int, cudaStream_t);
+
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_INT8      ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_UINT8     ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_INT16     ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_UINT16    ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_INT32     ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_UINT32    ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_INT64     ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_UINT64    ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_FLOAT16   ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_FLOAT32   ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_FLOAT64   ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128;
+  extern DeviceScanT cub_device_scan_cumsum_CUPY_TYPE_BOOL      ;
+
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_INT8      ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_UINT8     ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_INT16     ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_UINT16    ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_INT32     ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_UINT32    ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_INT64     ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_UINT64    ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_FLOAT16   ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_FLOAT32   ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_FLOAT64   ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128;
+  extern DeviceScanT cub_device_scan_cumprod_CUPY_TYPE_BOOL      ;
+
+  using DeviceSpmvT = void (void*, size_t&, void*, void*, void*, void*, void*, int, int, int, cudaStream_t);
+
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_INT8      ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_UINT8     ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_INT16     ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_UINT16    ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_INT32     ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_UINT32    ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_INT64     ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_UINT64    ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_FLOAT16   ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_FLOAT32   ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_FLOAT64   ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_COMPLEX64 ;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_COMPLEX128;
+  extern DeviceSpmvT cub_device_spmv_CUPY_TYPE_BOOL      ;
+
+  using DeviceHistRangeT = void (void*, size_t&, void*, void*, int, void*, size_t, cudaStream_t);
+
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_INT8      ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_UINT8     ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_INT16     ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_UINT16    ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_INT32     ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_UINT32    ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_INT64     ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_UINT64    ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_FLOAT16   ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_FLOAT32   ;
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_FLOAT64   ;
+  // no complex
+  extern DeviceHistRangeT cub_device_histogram_range_CUPY_TYPE_BOOL      ;
+
+  using DeviceHistEvenT = void (void*, size_t&, void*, void*, int, int, int, size_t, cudaStream_t);
+
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_INT8      ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_UINT8     ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_INT16     ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_UINT16    ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_INT32     ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_UINT32    ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_INT64     ;
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_UINT64    ;
+  // no floating types (including complex)
+  extern DeviceHistEvenT cub_device_histogram_even_CUPY_TYPE_BOOL      ;
+}
diff --git a/cupy/cuda/cupy_thrust.cu b/cupy/cuda/cupy_thrust.cu
index 9980f5b0b..1b93f3572 100644
--- a/cupy/cuda/cupy_thrust.cu
+++ b/cupy/cuda/cupy_thrust.cu
@@ -1,476 +1,62 @@
-#include <cupy/type_dispatcher.cuh>
-#include <thrust/device_ptr.h>
-#include <thrust/device_vector.h>
-#include <thrust/iterator/zip_iterator.h>
-#include <thrust/sequence.h>
-#include <thrust/sort.h>
-#include <thrust/tuple.h>
-#include <thrust/execution_policy.h>
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-// This is used to avoid a problem with constexpr in functions declarations introduced in
-// cuda 11.2, MSVC 15 does not fully support it so we need a dummy constexpr declaration
-// that is provided by this header. However optional.h is only available
-// starting CUDA 10.1
-#include <thrust/optional.h>
-
-#ifdef _MSC_VER
-#define THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS constexpr
-#else
-#define THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS THRUST_OPTIONAL_CPP11_CONSTEXPR
-#endif
+#include <functional>
 
-#endif
+#include <cupy/type_dispatcher.cuh>
 #include "cupy_thrust.h"
-
-
-#if CUPY_USE_HIP
-typedef hipStream_t cudaStream_t;
-namespace cuda {
-    using thrust::hip::par;
-}
-#else // #if CUPY_USE_HIP
-namespace cuda {
-    using thrust::cuda::par;
-}
-#endif // #if CUPY_USE_HIP
-
-
-extern "C" char *cupy_malloc(void *, size_t);
-extern "C" void cupy_free(void *, char *);
-
-
-class cupy_allocator {
-private:
-    void* memory;
-
-public:
-    typedef char value_type;
-
-    cupy_allocator(void* memory) : memory(memory) {}
-
-    char *allocate(size_t num_bytes) {
-        return cupy_malloc(memory, num_bytes);
-    }
-
-    void deallocate(char *ptr, size_t n) {
-        cupy_free(memory, ptr);
-    }
-};
-
-
-/*
- * ------------------------------------- Minimum boilerplate for NumPy compatibility --------------------------------------
- * We need a specialized operator< here in order to match the NumPy behavior:
- * "The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is
- * determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.
- *
- * In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is:
- *     Real: [R, nan]
- *     Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
- * where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if
- * it exists. Non-nan values are sorted as before."
- * Ref: https://numpy.org/doc/stable/reference/generated/numpy.sort.html
- */
-
-template <typename T>
-__host__ __device__ __forceinline__ 
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
-THRUST_OPTIONAL_CPP11_CONSTEXPR
-#endif
-bool _tuple_less(const thrust::tuple<size_t, T>& lhs,
-		 const thrust::tuple<size_t, T>& rhs) {
-    const size_t& lhs_k = lhs.template get<0>();
-    const size_t& rhs_k = rhs.template get<0>();
-    const T& lhs_v = lhs.template get<1>();
-    const T& rhs_v = rhs.template get<1>();
-    const thrust::less<T> _less;
-
-    // tuple's comparison rule: compare the 1st member, then 2nd, then 3rd, ...,
-    // which should be respected
-    if (lhs_k < rhs_k) {
-        return true;
-    } else if (lhs_k == rhs_k) {
-        // same key, compare values
-        // note that we can't rely on native operator< due to NaN, so we rely on
-        // thrust::less() to be specialized shortly
-        return _less(lhs_v, rhs_v);
-    } else {
-        return false;
-    }
-}
-
-/*
- * ********** complex numbers **********
- * We need to specialize thrust::less because obviously we can't overload operator< for complex numbers...
- */
-
-template <typename T>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
-THRUST_OPTIONAL_CPP11_CONSTEXPR
-#endif
-bool _cmp_less(const T& lhs, const T& rhs) {
-    bool lhsRe = isnan(lhs.real());
-    bool lhsIm = isnan(lhs.imag());
-    bool rhsRe = isnan(rhs.real());
-    bool rhsIm = isnan(rhs.imag());
-
-    // neither side has nan
-    if (!lhsRe && !lhsIm && !rhsRe && !rhsIm) {
-        return lhs < rhs;
-    }
-
-    // one side has nan, and the other does not
-    if (!lhsRe && !lhsIm && (rhsRe || rhsIm)) {
-        return true;
-    }
-    if ((lhsRe || lhsIm) && !rhsRe && !rhsIm) {
-        return false;
-    }
-
-    // pick 2 from 3 possibilities (R + nanj, nan + Rj, nan + nanj)
-    if (lhsRe && !rhsRe) {
-        return false;
-    }
-    if (!lhsRe && rhsRe) {
-        return true;
-    }
-    if (lhsIm && !rhsIm) {
-        return false;
-    }
-    if (!lhsIm && rhsIm) {
-        return true;
-    }
-
-    // pick 1 from 3 and compare the numerical values (nan+nan*I compares to itself as false)
-    return (((lhsIm && rhsIm) && (lhs.real() < rhs.real())) || ((lhsRe && rhsRe) && (lhs.imag() < rhs.imag())));
-}
-
-// specialize thrust::less for single complex
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less<complex<float>>::operator() (
-    const complex<float>& lhs, const complex<float>& rhs) const {
-
-    return _cmp_less<complex<float>>(lhs, rhs);
-}
-
-// specialize thrust::less for double complex
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less<complex<double>>::operator() (
-    const complex<double>& lhs, const complex<double>& rhs) const {
-
-    return _cmp_less<complex<double>>(lhs, rhs);
-}
-
-// specialize thrust::less for tuple<size_t, complex<float>>
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less< thrust::tuple<size_t, complex<float>> >::operator() (
-    const thrust::tuple<size_t, complex<float>>& lhs, const thrust::tuple<size_t, complex<float>>& rhs) const {
-
-    return _tuple_less<complex<float>>(lhs, rhs);
-}
-
-// specialize thrust::less for tuple<size_t, complex<double>>
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less< thrust::tuple<size_t, complex<double>> >::operator() (
-    const thrust::tuple<size_t, complex<double>>& lhs, const thrust::tuple<size_t, complex<double>>& rhs) const {
-
-    return _tuple_less<complex<double>>(lhs, rhs);
-}
-
-/*
- * ********** real numbers (templates) **********
- * We need to specialize thrust::less because obviously we can't overload operator< for floating point numbers...
- */
-
-template <typename T>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
-THRUST_OPTIONAL_CPP11_CONSTEXPR
-#endif
-bool _real_less(const T& lhs, const T& rhs) {
-    #if  (defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__))
-    if (isnan(lhs)) {
-        return false;
-    } else if (isnan(rhs)) {
-        return true;
-    } else {
-        return lhs < rhs;
-    }
-    #else
-    return false;  // This will be never executed in the host
-    #endif
-}
-
-/*
- * ********** real numbers (specializations for single & double precisions) **********
- */
-
-// specialize thrust::less for float
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less<float>::operator() (
-    const float& lhs, const float& rhs) const {
-
-    return _real_less<float>(lhs, rhs);
-}
-
-// specialize thrust::less for double
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less<double>::operator() (
-    const double& lhs, const double& rhs) const {
-
-    return _real_less<double>(lhs, rhs);
-}
-
-// specialize thrust::less for tuple<size_t, float>
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less< thrust::tuple<size_t, float> >::operator() (
-    const thrust::tuple<size_t, float>& lhs, const thrust::tuple<size_t, float>& rhs) const {
-
-    return _tuple_less<float>(lhs, rhs);
-}
-
-// specialize thrust::less for tuple<size_t, double>
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less< thrust::tuple<size_t, double> >::operator() (
-    const thrust::tuple<size_t, double>& lhs, const thrust::tuple<size_t, double>& rhs) const {
-
-    return _tuple_less<double>(lhs, rhs);
-}
-
-/*
- * ********** real numbers (specializations for half precision) **********
- */
-
-#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
-     && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
-
-// it seems Thrust doesn't care the code path on host, so we just need a wrapper for device
-__host__ __device__ __forceinline__ bool isnan(const __half& x) {
-    #if (defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__))
-    return __hisnan(x);
-    #else
-    return false;  // This will never be called on the host
-    #endif
-}
-
-// specialize thrust::less for __half
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less<__half>::operator() (const __half& lhs, const __half& rhs) const {
-    return _real_less<__half>(lhs, rhs);
-}
-
-// specialize thrust::less for tuple<size_t, __half>
-template <>
-__host__ __device__ __forceinline__
-#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
-THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
-#endif
-bool thrust::less< thrust::tuple<size_t, __half> >::operator() (
-    const thrust::tuple<size_t, __half>& lhs, const thrust::tuple<size_t, __half>& rhs) const {
-
-    return _tuple_less<__half>(lhs, rhs);
-}
-
-#endif  // include cupy_fp16.h
-
-/*
- * -------------------------------------------------- end of boilerplate --------------------------------------------------
- */
-
-
-/*
- * sort
- */
-
-struct _sort {
-    template <typename T>
-    __forceinline__ void operator()(void *data_start, size_t *keys_start,
-                                    const std::vector<ptrdiff_t>& shape, intptr_t stream,
-                                    void* memory) {
-        size_t ndim = shape.size();
-        ptrdiff_t size;
-	thrust::device_ptr<T> dp_data_first, dp_data_last;
-        thrust::device_ptr<size_t> dp_keys_first, dp_keys_last;
-        cudaStream_t stream_ = (cudaStream_t)stream;
-        cupy_allocator alloc(memory);
-
-        // Compute the total size of the array.
-        size = shape[0];
-        for (size_t i = 1; i < ndim; ++i) {
-            size *= shape[i];
-        }
-
-        dp_data_first = thrust::device_pointer_cast(static_cast<T*>(data_start));
-        dp_data_last  = thrust::device_pointer_cast(static_cast<T*>(data_start) + size);
-
-        if (ndim == 1) {
-            stable_sort(cuda::par(alloc).on(stream_), dp_data_first, dp_data_last, thrust::less<T>());
-        } else {
-            // Generate key indices.
-            dp_keys_first = thrust::device_pointer_cast(keys_start);
-            dp_keys_last  = thrust::device_pointer_cast(keys_start + size);
-            transform(cuda::par(alloc).on(stream_),
-                      thrust::make_counting_iterator<size_t>(0),
-                      thrust::make_counting_iterator<size_t>(size),
-                      thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
-                      dp_keys_first,
-                      thrust::divides<size_t>());
-
-            stable_sort(
-                cuda::par(alloc).on(stream_),
-                make_zip_iterator(make_tuple(dp_keys_first, dp_data_first)),
-                make_zip_iterator(make_tuple(dp_keys_last, dp_data_last)),
-                thrust::less< thrust::tuple<size_t, T> >());
-        }
-    }
-};
-
-
-/*
- * lexsort
- */
-
-template <typename T>
-class elem_less {
-public:
-    elem_less(const T *data):_data(data) {}
-    __device__ __forceinline__ bool operator()(size_t i, size_t j) const {
-        return thrust::less<T>()(_data[i], _data[j]);
-    }
-private:
-    const T *_data;
-};
-
-struct _lexsort {
-    template <typename T>
-    __forceinline__ void operator()(size_t *idx_start, void *keys_start, size_t k,
-                                    size_t n, intptr_t stream, void *memory) {
-        /* idx_start is the beginning of the output array where the indexes that
-           would sort the data will be placed. The original contents of idx_start
-           will be destroyed. */
-        thrust::device_ptr<size_t> dp_first = thrust::device_pointer_cast(idx_start);
-        thrust::device_ptr<size_t> dp_last  = thrust::device_pointer_cast(idx_start + n);
-        cudaStream_t stream_ = (cudaStream_t)stream;
-        cupy_allocator alloc(memory);
-        sequence(cuda::par(alloc).on(stream_), dp_first, dp_last);
-        for (size_t i = 0; i < k; ++i) {
-            T *key_start = static_cast<T*>(keys_start) + i * n;
-            stable_sort(
-                cuda::par(alloc).on(stream_),
-                dp_first,
-                dp_last,
-                elem_less<T>(key_start)
-            );
-        }
-    }
-};
-
-
-/*
- * argsort
- */
-
-struct _argsort {
-    template <typename T>
-    __forceinline__ void operator()(size_t *idx_start, void *data_start,
-                                    void *keys_start,
-                                    const std::vector<ptrdiff_t>& shape,
-                                    intptr_t stream, void *memory) {
-        /* idx_start is the beginning of the output array where the indexes that
-           would sort the data will be placed. The original contents of idx_start
-           will be destroyed. */
-
-        size_t ndim = shape.size();
-        ptrdiff_t size;
-        cudaStream_t stream_ = (cudaStream_t)stream;
-        cupy_allocator alloc(memory);
-
-        thrust::device_ptr<size_t> dp_idx_first, dp_idx_last;
-        thrust::device_ptr<T> dp_data_first, dp_data_last;
-        thrust::device_ptr<size_t> dp_keys_first, dp_keys_last;
-
-        // Compute the total size of the data array.
-        size = shape[0];
-        for (size_t i = 1; i < ndim; ++i) {
-            size *= shape[i];
-        }
-
-        // Cast device pointers of data.
-        dp_data_first = thrust::device_pointer_cast(static_cast<T*>(data_start));
-        dp_data_last  = thrust::device_pointer_cast(static_cast<T*>(data_start) + size);
-
-        // Generate an index sequence.
-        dp_idx_first = thrust::device_pointer_cast(static_cast<size_t*>(idx_start));
-        dp_idx_last  = thrust::device_pointer_cast(static_cast<size_t*>(idx_start) + size);
-        transform(cuda::par(alloc).on(stream_),
-                  thrust::make_counting_iterator<size_t>(0),
-                  thrust::make_counting_iterator<size_t>(size),
-                  thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
-                  dp_idx_first,
-                  thrust::modulus<size_t>());
-
-        if (ndim == 1) {
-            // Sort the index sequence by data.
-            stable_sort_by_key(cuda::par(alloc).on(stream_),
-                               dp_data_first,
-                               dp_data_last,
-                               dp_idx_first);
-        } else {
-            // Generate key indices.
-            dp_keys_first = thrust::device_pointer_cast(static_cast<size_t*>(keys_start));
-            dp_keys_last  = thrust::device_pointer_cast(static_cast<size_t*>(keys_start) + size);
-            transform(cuda::par(alloc).on(stream_),
-                      thrust::make_counting_iterator<size_t>(0),
-                      thrust::make_counting_iterator<size_t>(size),
-                      thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
-                      dp_keys_first,
-                      thrust::divides<size_t>());
-
-            stable_sort_by_key(
-                cuda::par(alloc).on(stream_),
-                make_zip_iterator(make_tuple(dp_keys_first, dp_data_first)),
-                make_zip_iterator(make_tuple(dp_keys_last, dp_data_last)),
-                dp_idx_first);
-        }
-    }
-};
+#include "cupy_thrust.inl"
+
+
+namespace cupy {
+  std::function<cupy::SortTargetT> sort_targets[CUPY_NUM_TYPES] = {
+    thrust_sort_CUPY_TYPE_INT8      ,
+    thrust_sort_CUPY_TYPE_UINT8     ,
+    thrust_sort_CUPY_TYPE_INT16     ,
+    thrust_sort_CUPY_TYPE_UINT16    ,
+    thrust_sort_CUPY_TYPE_INT32     ,
+    thrust_sort_CUPY_TYPE_UINT32    ,
+    thrust_sort_CUPY_TYPE_INT64     ,
+    thrust_sort_CUPY_TYPE_UINT64    ,
+    thrust_sort_CUPY_TYPE_FLOAT16   ,
+    thrust_sort_CUPY_TYPE_FLOAT32   ,
+    thrust_sort_CUPY_TYPE_FLOAT64   ,
+    thrust_sort_CUPY_TYPE_COMPLEX64 ,
+    thrust_sort_CUPY_TYPE_COMPLEX128,
+    thrust_sort_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::LexSortTargetT> lexsort_targets[CUPY_NUM_TYPES] = {
+    thrust_lexsort_CUPY_TYPE_INT8      ,
+    thrust_lexsort_CUPY_TYPE_UINT8     ,
+    thrust_lexsort_CUPY_TYPE_INT16     ,
+    thrust_lexsort_CUPY_TYPE_UINT16    ,
+    thrust_lexsort_CUPY_TYPE_INT32     ,
+    thrust_lexsort_CUPY_TYPE_UINT32    ,
+    thrust_lexsort_CUPY_TYPE_INT64     ,
+    thrust_lexsort_CUPY_TYPE_UINT64    ,
+    thrust_lexsort_CUPY_TYPE_FLOAT16   ,
+    thrust_lexsort_CUPY_TYPE_FLOAT32   ,
+    thrust_lexsort_CUPY_TYPE_FLOAT64   ,
+    thrust_lexsort_CUPY_TYPE_COMPLEX64 ,
+    thrust_lexsort_CUPY_TYPE_COMPLEX128,
+    thrust_lexsort_CUPY_TYPE_BOOL      ,
+  };
+
+  std::function<cupy::ArgSortTargetT> argsort_targets[CUPY_NUM_TYPES] = {
+    thrust_argsort_CUPY_TYPE_INT8      ,
+    thrust_argsort_CUPY_TYPE_UINT8     ,
+    thrust_argsort_CUPY_TYPE_INT16     ,
+    thrust_argsort_CUPY_TYPE_UINT16    ,
+    thrust_argsort_CUPY_TYPE_INT32     ,
+    thrust_argsort_CUPY_TYPE_UINT32    ,
+    thrust_argsort_CUPY_TYPE_INT64     ,
+    thrust_argsort_CUPY_TYPE_UINT64    ,
+    thrust_argsort_CUPY_TYPE_FLOAT16   ,
+    thrust_argsort_CUPY_TYPE_FLOAT32   ,
+    thrust_argsort_CUPY_TYPE_FLOAT64   ,
+    thrust_argsort_CUPY_TYPE_COMPLEX64 ,
+    thrust_argsort_CUPY_TYPE_COMPLEX128,
+    thrust_argsort_CUPY_TYPE_BOOL      ,
+  };
+}  // namespace cupy
 
 
 //
@@ -479,28 +65,47 @@ struct _argsort {
 
 /* -------- sort -------- */
 
-void thrust_sort(int dtype_id, void *data_start, size_t *keys_start,
-    const std::vector<ptrdiff_t>& shape, intptr_t stream, void* memory) {
-
-    _sort op;
-    return dtype_dispatcher(dtype_id, op, data_start, keys_start, shape, stream, memory);
+void thrust_sort(int dtype_id,
+                 void* data_start,
+                 size_t* keys_start,
+                 const std::vector<ptrdiff_t>& shape,
+                 intptr_t stream, 
+                 void* memory) {
+    return cupy::sort_targets[dtype_id](data_start,
+                                        keys_start,
+                                        shape,
+                                        stream,
+                                        memory);
 }
 
-
 /* -------- lexsort -------- */
-void thrust_lexsort(int dtype_id, size_t *idx_start, void *keys_start, size_t k,
-    size_t n, intptr_t stream, void *memory) {
-
-    _lexsort op;
-    return dtype_dispatcher(dtype_id, op, idx_start, keys_start, k, n, stream, memory);
+void thrust_lexsort(int dtype_id,
+                    size_t* idx_start,
+                    void* keys_start,
+                    size_t k,
+                    size_t n,
+                    intptr_t stream,
+                    void *memory) {
+    return cupy::lexsort_targets[dtype_id](idx_start,
+                                           keys_start,
+                                           k,
+                                           n,
+                                           stream,
+                                           memory);
 }
 
-
 /* -------- argsort -------- */
-void thrust_argsort(int dtype_id, size_t *idx_start, void *data_start,
-    void *keys_start, const std::vector<ptrdiff_t>& shape, intptr_t stream, void *memory) {
-
-    _argsort op;
-    return dtype_dispatcher(dtype_id, op, idx_start, data_start, keys_start, shape,
-                            stream, memory);
+void thrust_argsort(int dtype_id,
+                    size_t* idx_start,
+                    void* data_start,
+                    void* keys_start,
+                    const std::vector<ptrdiff_t>& shape,
+                    intptr_t stream,
+                    void *memory) {
+    return cupy::argsort_targets[dtype_id](idx_start,
+                                           data_start,
+                                           keys_start,
+                                           shape,
+                                           stream,
+                                           memory);
 }
diff --git a/cupy/cuda/cupy_thrust.h b/cupy/cuda/cupy_thrust.h
index b981ccff0..09662ce0d 100644
--- a/cupy/cuda/cupy_thrust.h
+++ b/cupy/cuda/cupy_thrust.h
@@ -1,6 +1,14 @@
 #ifndef INCLUDE_GUARD_CUPY_CUDA_THRUST_H
 #define INCLUDE_GUARD_CUPY_CUDA_THRUST_H
 
+#include <cstdint>
+#include <cstddef>
+#include <vector>
+
+using std::size_t;
+using std::ptrdiff_t;
+using std::intptr_t;
+
 #ifndef CUPY_NO_CUDA
 #include <thrust/version.h>  // for THRUST_VERSION
 
diff --git a/cupy/cuda/cupy_thrust.inl b/cupy/cuda/cupy_thrust.inl
new file mode 100644
index 000000000..07bea3486
--- /dev/null
+++ b/cupy/cuda/cupy_thrust.inl
@@ -0,0 +1,529 @@
+#include <cupy/type_dispatcher.cuh>
+#include <thrust/device_ptr.h>
+#include <thrust/device_vector.h>
+#include <thrust/iterator/zip_iterator.h>
+#include <thrust/sequence.h>
+#include <thrust/sort.h>
+#include <thrust/tuple.h>
+#include <thrust/execution_policy.h>
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+// This is used to avoid a problem with constexpr in functions declarations introduced in
+// cuda 11.2, MSVC 15 does not fully support it so we need a dummy constexpr declaration
+// that is provided by this header. However optional.h is only available
+// starting CUDA 10.1
+#include <thrust/optional.h>
+
+#ifdef _MSC_VER
+#define THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS constexpr
+#else
+#define THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS THRUST_OPTIONAL_CPP11_CONSTEXPR
+#endif
+
+#endif
+#include "cupy_thrust.h"
+
+
+#if CUPY_USE_HIP
+typedef hipStream_t cudaStream_t;
+namespace cuda {
+    using thrust::hip::par;
+}
+#else // #if CUPY_USE_HIP
+namespace cuda {
+    using thrust::cuda::par;
+}
+#endif // #if CUPY_USE_HIP
+
+
+extern "C" char *cupy_malloc(void *, size_t);
+extern "C" void cupy_free(void *, char *);
+
+
+class cupy_allocator {
+private:
+    void* memory;
+
+public:
+    typedef char value_type;
+
+    cupy_allocator(void* memory) : memory(memory) {}
+
+    char *allocate(size_t num_bytes) {
+        return cupy_malloc(memory, num_bytes);
+    }
+
+    void deallocate(char *ptr, size_t n) {
+        cupy_free(memory, ptr);
+    }
+};
+
+
+/*
+ * ------------------------------------- Minimum boilerplate for NumPy compatibility --------------------------------------
+ * We need a specialized operator< here in order to match the NumPy behavior:
+ * "The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is
+ * determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.
+ *
+ * In numpy versions >= 1.4.0 nan values are sorted to the end. The extended sort order is:
+ *     Real: [R, nan]
+ *     Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
+ * where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if
+ * it exists. Non-nan values are sorted as before."
+ * Ref: https://numpy.org/doc/stable/reference/generated/numpy.sort.html
+ */
+
+template <typename T>
+__host__ __device__ __forceinline__ 
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
+THRUST_OPTIONAL_CPP11_CONSTEXPR
+#endif
+bool _tuple_less(const thrust::tuple<size_t, T>& lhs,
+		 const thrust::tuple<size_t, T>& rhs) {
+    const size_t& lhs_k = lhs.template get<0>();
+    const size_t& rhs_k = rhs.template get<0>();
+    const T& lhs_v = lhs.template get<1>();
+    const T& rhs_v = rhs.template get<1>();
+    const thrust::less<T> _less;
+
+    // tuple's comparison rule: compare the 1st member, then 2nd, then 3rd, ...,
+    // which should be respected
+    if (lhs_k < rhs_k) {
+        return true;
+    } else if (lhs_k == rhs_k) {
+        // same key, compare values
+        // note that we can't rely on native operator< due to NaN, so we rely on
+        // thrust::less() to be specialized shortly
+        return _less(lhs_v, rhs_v);
+    } else {
+        return false;
+    }
+}
+
+/*
+ * ********** complex numbers **********
+ * We need to specialize thrust::less because obviously we can't overload operator< for complex numbers...
+ */
+
+template <typename T>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
+THRUST_OPTIONAL_CPP11_CONSTEXPR
+#endif
+bool _cmp_less(const T& lhs, const T& rhs) {
+    bool lhsRe = isnan(lhs.real());
+    bool lhsIm = isnan(lhs.imag());
+    bool rhsRe = isnan(rhs.real());
+    bool rhsIm = isnan(rhs.imag());
+
+    // neither side has nan
+    if (!lhsRe && !lhsIm && !rhsRe && !rhsIm) {
+        return lhs < rhs;
+    }
+
+    // one side has nan, and the other does not
+    if (!lhsRe && !lhsIm && (rhsRe || rhsIm)) {
+        return true;
+    }
+    if ((lhsRe || lhsIm) && !rhsRe && !rhsIm) {
+        return false;
+    }
+
+    // pick 2 from 3 possibilities (R + nanj, nan + Rj, nan + nanj)
+    if (lhsRe && !rhsRe) {
+        return false;
+    }
+    if (!lhsRe && rhsRe) {
+        return true;
+    }
+    if (lhsIm && !rhsIm) {
+        return false;
+    }
+    if (!lhsIm && rhsIm) {
+        return true;
+    }
+
+    // pick 1 from 3 and compare the numerical values (nan+nan*I compares to itself as false)
+    return (((lhsIm && rhsIm) && (lhs.real() < rhs.real())) || ((lhsRe && rhsRe) && (lhs.imag() < rhs.imag())));
+}
+
+// specialize thrust::less for single complex
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less<complex<float>>::operator() (
+    const complex<float>& lhs, const complex<float>& rhs) const {
+
+    return _cmp_less<complex<float>>(lhs, rhs);
+}
+
+// specialize thrust::less for double complex
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less<complex<double>>::operator() (
+    const complex<double>& lhs, const complex<double>& rhs) const {
+
+    return _cmp_less<complex<double>>(lhs, rhs);
+}
+
+// specialize thrust::less for tuple<size_t, complex<float>>
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less< thrust::tuple<size_t, complex<float>> >::operator() (
+    const thrust::tuple<size_t, complex<float>>& lhs, const thrust::tuple<size_t, complex<float>>& rhs) const {
+
+    return _tuple_less<complex<float>>(lhs, rhs);
+}
+
+// specialize thrust::less for tuple<size_t, complex<double>>
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less< thrust::tuple<size_t, complex<double>> >::operator() (
+    const thrust::tuple<size_t, complex<double>>& lhs, const thrust::tuple<size_t, complex<double>>& rhs) const {
+
+    return _tuple_less<complex<double>>(lhs, rhs);
+}
+
+/*
+ * ********** real numbers (templates) **********
+ * We need to specialize thrust::less because obviously we can't overload operator< for floating point numbers...
+ */
+
+template <typename T>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2))
+THRUST_OPTIONAL_CPP11_CONSTEXPR
+#endif
+bool _real_less(const T& lhs, const T& rhs) {
+    #if  (defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__))
+    if (isnan(lhs)) {
+        return false;
+    } else if (isnan(rhs)) {
+        return true;
+    } else {
+        return lhs < rhs;
+    }
+    #else
+    return false;  // This will be never executed in the host
+    #endif
+}
+
+/*
+ * ********** real numbers (specializations for single & double precisions) **********
+ */
+
+// specialize thrust::less for float
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less<float>::operator() (
+    const float& lhs, const float& rhs) const {
+
+    return _real_less<float>(lhs, rhs);
+}
+
+// specialize thrust::less for double
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less<double>::operator() (
+    const double& lhs, const double& rhs) const {
+
+    return _real_less<double>(lhs, rhs);
+}
+
+// specialize thrust::less for tuple<size_t, float>
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less< thrust::tuple<size_t, float> >::operator() (
+    const thrust::tuple<size_t, float>& lhs, const thrust::tuple<size_t, float>& rhs) const {
+
+    return _tuple_less<float>(lhs, rhs);
+}
+
+// specialize thrust::less for tuple<size_t, double>
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less< thrust::tuple<size_t, double> >::operator() (
+    const thrust::tuple<size_t, double>& lhs, const thrust::tuple<size_t, double>& rhs) const {
+
+    return _tuple_less<double>(lhs, rhs);
+}
+
+/*
+ * ********** real numbers (specializations for half precision) **********
+ */
+
+#if ((__CUDACC_VER_MAJOR__ > 9 || (__CUDACC_VER_MAJOR__ == 9 && __CUDACC_VER_MINOR__ == 2)) \
+     && (__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))) || (defined(__HIPCC__) || defined(CUPY_USE_HIP))
+
+// it seems Thrust doesn't care the code path on host, so we just need a wrapper for device
+__host__ __device__ __forceinline__ bool isnan(const __half& x) {
+    #if (defined(__CUDA_ARCH__) || defined(__HIP_DEVICE_COMPILE__))
+    return __hisnan(x);
+    #else
+    return false;  // This will never be called on the host
+    #endif
+}
+
+// specialize thrust::less for __half
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less<__half>::operator() (const __half& lhs, const __half& rhs) const {
+    return _real_less<__half>(lhs, rhs);
+}
+
+// specialize thrust::less for tuple<size_t, __half>
+template <>
+__host__ __device__ __forceinline__
+#if (__CUDACC_VER_MAJOR__ >11 || (__CUDACC_VER_MAJOR__ == 11 && __CUDACC_VER_MINOR__ >= 2) || HIP_VERSION >= 402)
+THRUST_OPTIONAL_CPP11_CONSTEXPR_LESS
+#endif
+bool thrust::less< thrust::tuple<size_t, __half> >::operator() (
+    const thrust::tuple<size_t, __half>& lhs, const thrust::tuple<size_t, __half>& rhs) const {
+
+    return _tuple_less<__half>(lhs, rhs);
+}
+
+#endif  // include cupy_fp16.h
+
+/*
+ * -------------------------------------------------- end of boilerplate --------------------------------------------------
+ */
+
+
+/*
+ * sort
+ */
+
+struct _sort {
+    template <typename T>
+    __forceinline__ void operator()(void *data_start, size_t *keys_start,
+                                    const std::vector<ptrdiff_t>& shape, intptr_t stream,
+                                    void* memory) {
+        size_t ndim = shape.size();
+        ptrdiff_t size;
+	thrust::device_ptr<T> dp_data_first, dp_data_last;
+        thrust::device_ptr<size_t> dp_keys_first, dp_keys_last;
+        cudaStream_t stream_ = (cudaStream_t)stream;
+        cupy_allocator alloc(memory);
+
+        // Compute the total size of the array.
+        size = shape[0];
+        for (size_t i = 1; i < ndim; ++i) {
+            size *= shape[i];
+        }
+
+        dp_data_first = thrust::device_pointer_cast(static_cast<T*>(data_start));
+        dp_data_last  = thrust::device_pointer_cast(static_cast<T*>(data_start) + size);
+
+        if (ndim == 1) {
+            stable_sort(cuda::par(alloc).on(stream_), dp_data_first, dp_data_last, thrust::less<T>());
+        } else {
+            // Generate key indices.
+            dp_keys_first = thrust::device_pointer_cast(keys_start);
+            dp_keys_last  = thrust::device_pointer_cast(keys_start + size);
+            transform(cuda::par(alloc).on(stream_),
+                      thrust::make_counting_iterator<size_t>(0),
+                      thrust::make_counting_iterator<size_t>(size),
+                      thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
+                      dp_keys_first,
+                      thrust::divides<size_t>());
+
+            stable_sort(
+                cuda::par(alloc).on(stream_),
+                make_zip_iterator(make_tuple(dp_keys_first, dp_data_first)),
+                make_zip_iterator(make_tuple(dp_keys_last, dp_data_last)),
+                thrust::less< thrust::tuple<size_t, T> >());
+        }
+    }
+};
+
+
+/*
+ * lexsort
+ */
+
+template <typename T>
+class elem_less {
+public:
+    elem_less(const T *data):_data(data) {}
+    __device__ __forceinline__ bool operator()(size_t i, size_t j) const {
+        return thrust::less<T>()(_data[i], _data[j]);
+    }
+private:
+    const T *_data;
+};
+
+struct _lexsort {
+    template <typename T>
+    __forceinline__ void operator()(size_t *idx_start, void *keys_start, size_t k,
+                                    size_t n, intptr_t stream, void *memory) {
+        /* idx_start is the beginning of the output array where the indexes that
+           would sort the data will be placed. The original contents of idx_start
+           will be destroyed. */
+        thrust::device_ptr<size_t> dp_first = thrust::device_pointer_cast(idx_start);
+        thrust::device_ptr<size_t> dp_last  = thrust::device_pointer_cast(idx_start + n);
+        cudaStream_t stream_ = (cudaStream_t)stream;
+        cupy_allocator alloc(memory);
+        sequence(cuda::par(alloc).on(stream_), dp_first, dp_last);
+        for (size_t i = 0; i < k; ++i) {
+            T *key_start = static_cast<T*>(keys_start) + i * n;
+            stable_sort(
+                cuda::par(alloc).on(stream_),
+                dp_first,
+                dp_last,
+                elem_less<T>(key_start)
+            );
+        }
+    }
+};
+
+
+/*
+ * argsort
+ */
+
+struct _argsort {
+    template <typename T>
+    __forceinline__ void operator()(size_t *idx_start, void *data_start,
+                                    void *keys_start,
+                                    const std::vector<ptrdiff_t>& shape,
+                                    intptr_t stream, void *memory) {
+        /* idx_start is the beginning of the output array where the indexes that
+           would sort the data will be placed. The original contents of idx_start
+           will be destroyed. */
+
+        size_t ndim = shape.size();
+        ptrdiff_t size;
+        cudaStream_t stream_ = (cudaStream_t)stream;
+        cupy_allocator alloc(memory);
+
+        thrust::device_ptr<size_t> dp_idx_first, dp_idx_last;
+        thrust::device_ptr<T> dp_data_first, dp_data_last;
+        thrust::device_ptr<size_t> dp_keys_first, dp_keys_last;
+
+        // Compute the total size of the data array.
+        size = shape[0];
+        for (size_t i = 1; i < ndim; ++i) {
+            size *= shape[i];
+        }
+
+        // Cast device pointers of data.
+        dp_data_first = thrust::device_pointer_cast(static_cast<T*>(data_start));
+        dp_data_last  = thrust::device_pointer_cast(static_cast<T*>(data_start) + size);
+
+        // Generate an index sequence.
+        dp_idx_first = thrust::device_pointer_cast(static_cast<size_t*>(idx_start));
+        dp_idx_last  = thrust::device_pointer_cast(static_cast<size_t*>(idx_start) + size);
+        transform(cuda::par(alloc).on(stream_),
+                  thrust::make_counting_iterator<size_t>(0),
+                  thrust::make_counting_iterator<size_t>(size),
+                  thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
+                  dp_idx_first,
+                  thrust::modulus<size_t>());
+
+        if (ndim == 1) {
+            // Sort the index sequence by data.
+            stable_sort_by_key(cuda::par(alloc).on(stream_),
+                               dp_data_first,
+                               dp_data_last,
+                               dp_idx_first);
+        } else {
+            // Generate key indices.
+            dp_keys_first = thrust::device_pointer_cast(static_cast<size_t*>(keys_start));
+            dp_keys_last  = thrust::device_pointer_cast(static_cast<size_t*>(keys_start) + size);
+            transform(cuda::par(alloc).on(stream_),
+                      thrust::make_counting_iterator<size_t>(0),
+                      thrust::make_counting_iterator<size_t>(size),
+                      thrust::make_constant_iterator<ptrdiff_t>(shape[ndim-1]),
+                      dp_keys_first,
+                      thrust::divides<size_t>());
+
+            stable_sort_by_key(
+                cuda::par(alloc).on(stream_),
+                make_zip_iterator(make_tuple(dp_keys_first, dp_data_first)),
+                make_zip_iterator(make_tuple(dp_keys_last, dp_data_last)),
+                dp_idx_first);
+        }
+    }
+};
+
+
+//
+// Placeholders for storing function pointers to the template specializations
+// Note: no template instatiation should be done in this file!
+//
+
+namespace cupy {
+  using SortTargetT = void (void*, size_t*, const std::vector<ptrdiff_t>&, intptr_t, void*);
+  extern SortTargetT thrust_sort_CUPY_TYPE_INT8      ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_UINT8     ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_INT16     ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_UINT16    ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_INT32     ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_UINT32    ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_INT64     ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_UINT64    ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_FLOAT16   ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_FLOAT32   ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_FLOAT64   ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_COMPLEX64 ;
+  extern SortTargetT thrust_sort_CUPY_TYPE_COMPLEX128;
+  extern SortTargetT thrust_sort_CUPY_TYPE_BOOL      ;
+
+  using LexSortTargetT = void (size_t*, void*, size_t, size_t, intptr_t, void*);
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_INT8      ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_UINT8     ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_INT16     ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_UINT16    ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_INT32     ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_UINT32    ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_INT64     ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_UINT64    ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_FLOAT16   ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_FLOAT32   ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_FLOAT64   ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_COMPLEX64 ;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_COMPLEX128;
+  extern LexSortTargetT thrust_lexsort_CUPY_TYPE_BOOL      ;
+
+  using ArgSortTargetT = void (size_t*, void*, void*, const std::vector<ptrdiff_t>&, intptr_t, void*);
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_INT8      ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_UINT8     ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_INT16     ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_UINT16    ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_INT32     ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_UINT32    ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_INT64     ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_UINT64    ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_FLOAT16   ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_FLOAT32   ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_FLOAT64   ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_COMPLEX64 ;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_COMPLEX128;
+  extern ArgSortTargetT thrust_argsort_CUPY_TYPE_BOOL      ;
+}
diff --git a/cupy/cuda/detail/README.md b/cupy/cuda/detail/README.md
new file mode 100644
index 000000000..1333ed77b
--- /dev/null
+++ b/cupy/cuda/detail/README.md
@@ -0,0 +1 @@
+TODO
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even.template b/cupy/cuda/detail/cupy_cub_device_histogram_even.template
new file mode 100644
index 000000000..0efe91697
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even.template
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_<CODENAME>(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..ac1760402
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_BOOL(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..7cbad8212
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT16.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_INT16(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..128cbe465
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT32.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_INT32(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..12648aab8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT64.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_INT64(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..58a487fbe
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_INT8.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_INT8(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..042c42e13
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_UINT16(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..07b6da084
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_UINT32(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..35f58b5ff
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_UINT64(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..8c45329c1
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_even_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,37 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_even_CUPY_TYPE_UINT8(void* workspace,
+                                          size_t& workspace_size,
+                                          void* x,
+                                          void* y,
+                                          int n_bins,
+                                          int lower,
+                                          int upper,
+                                          size_t n_samples,
+                                          cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_histogram_even op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         lower,
+                                         upper,
+                                         n_samples,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range.template b/cupy/cuda/detail/cupy_cub_device_histogram_range.template
new file mode 100644
index 000000000..1d5f6f53c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range.template
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_<CODENAME>(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..6029e53be
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_BOOL(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..c440b0c29
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_FLOAT16(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..31eb5dba9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_FLOAT32(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..7a65b8d01
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_FLOAT64(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..c0dea79b5
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT16.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_INT16(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..e00a9f31a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT32.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_INT32(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..29143fe62
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT64.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_INT64(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..6eab843c9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_INT8.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_INT8(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..860928205
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_UINT16(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..c02d1eeb9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_UINT32(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..c75fd5783
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_UINT64(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..f590c6c47
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_histogram_range_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,34 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_histogram_range_CUPY_TYPE_UINT8(void* workspace,
+                                           size_t& workspace_size,
+                                           void* x,
+                                           void* y,
+                                           int n_bins,
+                                           void* bins,
+                                           size_t n_samples,
+                                           cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // TODO(leofang): n_samples is of type size_t, but if it's < 2^31 we cast it to int later
+    _cub_histogram_range op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         n_bins,
+                                         bins,
+                                         n_samples,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax.template b/cupy/cuda/detail/cupy_cub_device_reduce_argmax.template
new file mode 100644
index 000000000..d4adfc206
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax.template
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_<CODENAME>(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..5615849b4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_BOOL(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..fb7834eb3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_COMPLEX128(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..79f231a2b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_COMPLEX64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..1e5eaed40
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_FLOAT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..e7e05b103
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_FLOAT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..fbacf00f7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_FLOAT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..90247babc
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_INT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..2ca187eda
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_INT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..265aefe26
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_INT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..2a6532caf
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_INT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_INT8(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..973cf839e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_UINT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..de8224b88
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_UINT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..8edc23520
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_UINT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..b0122401a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmax_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmax_CUPY_TYPE_UINT8(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmax op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin.template b/cupy/cuda/detail/cupy_cub_device_reduce_argmin.template
new file mode 100644
index 000000000..be16d7112
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin.template
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_<CODENAME>(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..7a5997c61
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_BOOL(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..66e1d2ab4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_COMPLEX128(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..ab1e94dc2
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_COMPLEX64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..2585ec0f7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_FLOAT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..d8d2efcb9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_FLOAT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..47573a985
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_FLOAT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..ee6c0e019
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_INT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..a3732211c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_INT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..8f8e426b2
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_INT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..1aba04a12
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_INT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_INT8(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..1dd1f9e5e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_UINT16(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..54ee4c64d
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_UINT32(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..ef389877c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_UINT64(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..ee4eece05
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_argmin_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_argmin_CUPY_TYPE_UINT8(void* workspace,
+                                         size_t& workspace_size,
+                                         void* x,
+                                         void* y,
+                                         int num_items,
+                                         cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_argmin op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max.template b/cupy/cuda/detail/cupy_cub_device_reduce_max.template
new file mode 100644
index 000000000..7a45b7a2b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max.template
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_<CODENAME>(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..61f55b736
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_BOOL(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..ed8cc6e89
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_COMPLEX128(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..029027e71
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_COMPLEX64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..c48c66dcf
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_FLOAT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..1e18ff3a4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_FLOAT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..efbddca67
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_FLOAT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..b382cb2b7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_INT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..ee9d3399c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_INT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..7c4372f2c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_INT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..ce3422013
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_INT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_INT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..a912228fb
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_UINT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..cd8c7a4b0
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_UINT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..811be8cee
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_UINT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..b9fb4b018
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_max_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_max_CUPY_TYPE_UINT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_max op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min.template b/cupy/cuda/detail/cupy_cub_device_reduce_min.template
new file mode 100644
index 000000000..6abd1dc41
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min.template
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_<CODENAME>(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..00de1c93b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_BOOL(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..27df58df6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_COMPLEX128(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..3db4a60a8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_COMPLEX64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..683b98d2d
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_FLOAT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..5806e9552
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_FLOAT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..c7b656acb
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_FLOAT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..84b8a4499
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_INT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..90d206739
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_INT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..fae7e8171
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_INT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..bb4c774b8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_INT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_INT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..a59190bc8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_UINT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..def7f99cf
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_UINT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..b340ef32e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_UINT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..9f7fcd720
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_min_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_min_CUPY_TYPE_UINT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_min op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod.template b/cupy/cuda/detail/cupy_cub_device_reduce_prod.template
new file mode 100644
index 000000000..b2551abb5
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod.template
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_<CODENAME>(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..9b366cc53
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_BOOL(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..89571c87e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_COMPLEX128(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..6c6bbb322
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_COMPLEX64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..90f968630
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_FLOAT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..dae32a347
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_FLOAT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..33ae2c7e7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_FLOAT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..66d1ebfd3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_INT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..d83bc5c67
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_INT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..d8e9a8f6f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_INT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..b68aae9f0
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_INT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_INT8(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..10b7d17b4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_UINT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..efcdce8e2
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_UINT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..6646569ae
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_UINT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..82b20bf75
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_prod_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_prod_CUPY_TYPE_UINT8(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_prod op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum.template b/cupy/cuda/detail/cupy_cub_device_reduce_sum.template
new file mode 100644
index 000000000..e25343991
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum.template
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_<CODENAME>(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..1c734ba35
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_BOOL(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..31e0dfba1
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_COMPLEX128(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..d15800bb1
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_COMPLEX64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..6248c4442
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_FLOAT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..2409d22a4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_FLOAT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..6f4d751af
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_FLOAT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..e730b34be
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_INT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..312910c55
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_INT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..50ca72e0c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_INT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..38936ab91
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_INT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_INT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..91cc2b67e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_UINT16(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..b7548f3a5
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_UINT32(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..37a743fbf
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_UINT64(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..83b79c286
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_reduce_sum_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_reduce_sum_CUPY_TYPE_UINT8(void* workspace,
+                                      size_t& workspace_size,
+                                      void* x,
+                                      void* y,
+                                      int num_items,
+                                      cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_reduce_sum op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod.template b/cupy/cuda/detail/cupy_cub_device_scan_cumprod.template
new file mode 100644
index 000000000..a86ce6530
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod.template
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_<CODENAME>(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..fd16716ca
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_BOOL(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..2e4de93f4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_COMPLEX128(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..142903883
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_COMPLEX64(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..a6e1d9266
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_FLOAT16(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..5a30ba18b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_FLOAT32(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..770eb0737
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_FLOAT64(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..55f82ac02
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_INT16(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..3a6191179
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_INT32(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..b235ed4dc
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_INT64(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..4a21e35c4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_INT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_INT8(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..5f4b2a055
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_UINT16(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..cdb5c7f8d
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_UINT32(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..05f348226
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_UINT64(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..6cc1900a7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumprod_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumprod_CUPY_TYPE_UINT8(void* workspace,
+                                        size_t& workspace_size,
+                                        void* x,
+                                        void* y,
+                                        int num_items,
+                                        cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_product op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum.template b/cupy/cuda/detail/cupy_cub_device_scan_cumsum.template
new file mode 100644
index 000000000..be25990a8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum.template
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_<CODENAME>(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..279b3cfcd
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_BOOL(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..fbd811994
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_COMPLEX128(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..d1161b32b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_COMPLEX64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..172b5866a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_FLOAT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..558efe72e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_FLOAT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..7ff4b3786
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_FLOAT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..7cef06972
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_INT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..729dfae20
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_INT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..d2c6b49c9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_INT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..3d37cb7d6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_INT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_INT8(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..bdd379f58
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_UINT16(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..958fb0bf3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_UINT32(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..b586ca94f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_UINT64(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..3d35df036
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_scan_cumsum_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,28 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_scan_cumsum_CUPY_TYPE_UINT8(void* workspace,
+                                       size_t& workspace_size,
+                                       void* x,
+                                       void* y,
+                                       int num_items,
+                                       cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_inclusive_sum op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_items,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max.template b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max.template
new file mode 100644
index 000000000..b7a6ea7b0
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max.template
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_<CODENAME>(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..8cd5127b8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_BOOL(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..43b7db753
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX128(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..2ca48af4c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_COMPLEX64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..f8c920487
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..3adf3f9bc
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..10d9f45dd
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_FLOAT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..1286d1491
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_INT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..6675addea
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_INT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..4629bc4cf
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_INT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..456392c16
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_INT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_INT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..e9031eee6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_UINT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..e87e56211
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_UINT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..bfaf35674
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_UINT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..478a6a2fb
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_max_CUPY_TYPE_UINT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_max op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min.template b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min.template
new file mode 100644
index 000000000..43e60a402
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min.template
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_<CODENAME>(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..fd5c2e432
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_BOOL(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..be71f0d98
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX128(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..e69c67a02
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_COMPLEX64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..27f735583
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..f1b5cd959
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..c4d4e986d
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_FLOAT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..f43512780
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_INT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..64b199c0d
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_INT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..c564d1e1c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_INT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..5ecce1f5e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_INT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_INT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..aa8103eb3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_UINT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..7a344f01c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_UINT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..84cb85276
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_UINT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..5a48955b1
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_min_CUPY_TYPE_UINT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_min op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod.template b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod.template
new file mode 100644
index 000000000..b534c5bfa
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod.template
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_<CODENAME>(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..bf0b0b2d6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_BOOL(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..16e29dbe4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX128(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..b4a5ade04
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_COMPLEX64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..204aa741f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..2a6e23cfa
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..63be4c9b5
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_FLOAT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..61033ff4f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_INT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..51fdd6ace
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_INT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..68d5bf32e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_INT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..6dd45d8c0
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_INT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_INT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..63667eda2
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_UINT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..3451a7bbe
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_UINT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..043a0c150
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_UINT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..a6570bac8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_prod_CUPY_TYPE_UINT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_prod op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum.template b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum.template
new file mode 100644
index 000000000..6b9a90cd1
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum.template
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_<CODENAME>(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..648454d5c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_BOOL(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..5df61829e
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX128(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..489aac127
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_COMPLEX64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..c8f632be2
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..dcaae2423
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..cda038bd4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_FLOAT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..23adbf863
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_INT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..730b01c4c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_INT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..6843db9cb
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_INT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..f970dda49
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_INT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_INT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..c88205d63
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_UINT16(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..b1930e3ca
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_UINT32(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..b6daf73fc
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_UINT64(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..0535d38df
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,40 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_segmented_reduce_sum_CUPY_TYPE_UINT8(void* workspace,
+                                                size_t& workspace_size,
+                                                void* x,
+                                                void* y,
+                                                int num_segments,
+                                                int segment_size,
+                                                cudaStream_t stream) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    // CUB internally use int for offset...
+    // This iterates over [0, segment_size, 2*segment_size, 3*segment_size, ...]
+    #ifndef CUPY_USE_HIP
+    CountingInputIterator<int> count_itr(0);
+    #else
+    rocprim::counting_iterator<int> count_itr(0);
+    #endif
+    _arange scaling(segment_size);
+    seg_offset_itr itr(count_itr, scaling);
+
+    _cub_segmented_reduce_sum op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         x,
+                                         y,
+                                         num_segments,
+                                         itr,
+                                         stream);
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv.template b/cupy/cuda/detail/cupy_cub_device_spmv.template
new file mode 100644
index 000000000..d8f92c013
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv.template
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_<CODENAME>(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..939288d96
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_BOOL(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< bool >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..96ce94543
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_COMPLEX128(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< complex<double> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..c6c5359da
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_COMPLEX64(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< complex<float> >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..0e9235193
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_FLOAT16(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< __half >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..42315a06f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_FLOAT32(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< float >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..1844eef25
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_FLOAT64(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< double >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..042c41e99
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT16.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_INT16(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..200de4186
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT32.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_INT32(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..435a1bee8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT64.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_INT64(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< int64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..ff6655117
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_INT8.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_INT8(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..a0bf84497
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_UINT16(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< unsigned short >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..f64709e10
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_UINT32(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< unsigned int >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..948038a41
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_UINT64(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< uint64_t >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..067b20a6c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_cub_device_spmv_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,41 @@
+#include "../cupy_cub.inl"
+
+
+namespace cupy {
+
+void cub_device_spmv_CUPY_TYPE_UINT8(void* workspace,
+                                size_t& workspace_size,
+                                void* values,
+                                void* row_offsets,
+                                void* column_indices,
+                                void* x,
+                                void* y,
+                                int num_rows,
+                                int num_cols,
+                                int num_nonzeros,
+                                cudaStream_t stream) {
+#ifndef CUPY_USE_HIP
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _cub_device_spmv op;
+    return dtype_forwarder< unsigned char >(op,
+                                         workspace,
+                                         workspace_size,
+                                         values,
+                                         row_offsets,
+                                         column_indices,
+                                         x,
+                                         y,
+                                         num_rows,
+                                         num_cols,
+                                         num_nonzeros,
+                                         stream);
+
+#endif
+#endif  // CUPY_USE_HIP
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort.template b/cupy/cuda/detail/cupy_thrust_argsort.template
new file mode 100644
index 000000000..77d202f50
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort.template
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_<CODENAME>(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< <TYPENAME> >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..5ba0eb4b7
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_BOOL(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< bool >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..6fdf882fa
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_COMPLEX128(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< complex<double> >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..0612df07f
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_COMPLEX64(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< complex<float> >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..1822ed000
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_FLOAT16(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< __half >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..c23d0f9c0
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_FLOAT32(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< float >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..3eab6fdda
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_FLOAT64(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< double >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..d4772cce9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_INT16(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< short >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..c053ba63a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_INT32(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< int >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..d64306489
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_INT64(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< int64_t >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..877afb718
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_INT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_INT8(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< char >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..6def2a0fd
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_UINT16(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< unsigned short >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..d7e434cd6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_UINT32(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< unsigned int >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..00ccb7ac8
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_UINT64(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< uint64_t >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..8241a2719
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_argsort_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy{
+
+void thrust_argsort_CUPY_TYPE_UINT8(size_t *idx_start,
+                               void *data_start,
+                               void *keys_start,
+                               const std::vector<ptrdiff_t>& shape, 
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _argsort op;
+    return dtype_forwarder< unsigned char >(op, 
+                                         idx_start,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort.template b/cupy/cuda/detail/cupy_thrust_lexsort.template
new file mode 100644
index 000000000..3a49e37ce
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort.template
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_<CODENAME>(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..2a45ba418
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_BOOL(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< bool >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..04f6283c9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_COMPLEX128(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< complex<double> >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..a5eb563de
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_COMPLEX64(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< complex<float> >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..e1885203a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_FLOAT16(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< __half >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..3abfb1e9b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_FLOAT32(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< float >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..ec4cf6c50
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_FLOAT64(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< double >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..1ff0444d6
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_INT16(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< short >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..de480ec87
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_INT32(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< int >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..f240c4ba5
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_INT64(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< int64_t >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..103aa6f0b
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_INT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_INT8(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< char >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..30afce7a3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_UINT16(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< unsigned short >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..d4ff1a828
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_UINT32(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< unsigned int >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..b2c8c74d3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_UINT64(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< uint64_t >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..a4548a709
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_lexsort_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,29 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_lexsort_CUPY_TYPE_UINT8(size_t *idx_start,
+                               void *keys_start,
+                               size_t k,
+                               size_t n,
+                               intptr_t stream,
+                               void *memory) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _lexsort op;
+    return dtype_forwarder< unsigned char >(op,
+                                         idx_start,
+                                         keys_start,
+                                         k,
+                                         n,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort.template b/cupy/cuda/detail/cupy_thrust_sort.template
new file mode 100644
index 000000000..bb2a390ce
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort.template
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_<CODENAME>(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( <CODENAME> != CUPY_TYPE_FLOAT16 )                        \
+    || (( <CODENAME> == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< <TYPENAME> >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_BOOL.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_BOOL.cu
new file mode 100644
index 000000000..6b1e0d987
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_BOOL.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_BOOL(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_BOOL != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_BOOL == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< bool >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX128.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX128.cu
new file mode 100644
index 000000000..061b86f09
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX128.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_COMPLEX128(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_COMPLEX128 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX128 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< complex<double> >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX64.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX64.cu
new file mode 100644
index 000000000..3e92f8c39
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_COMPLEX64.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_COMPLEX64(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_COMPLEX64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_COMPLEX64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< complex<float> >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT16.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT16.cu
new file mode 100644
index 000000000..1b40285ff
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT16.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_FLOAT16(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_FLOAT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< __half >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT32.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT32.cu
new file mode 100644
index 000000000..53f7e7c2c
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT32.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_FLOAT32(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_FLOAT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< float >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT64.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT64.cu
new file mode 100644
index 000000000..956aea5e3
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_FLOAT64.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_FLOAT64(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_FLOAT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_FLOAT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< double >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT16.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT16.cu
new file mode 100644
index 000000000..e94431de4
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT16.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_INT16(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_INT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< short >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT32.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT32.cu
new file mode 100644
index 000000000..f551757ba
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT32.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_INT32(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_INT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< int >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT64.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT64.cu
new file mode 100644
index 000000000..27ea721fe
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT64.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_INT64(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_INT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< int64_t >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT8.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT8.cu
new file mode 100644
index 000000000..2901164cb
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_INT8.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_INT8(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_INT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_INT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< char >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT16.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT16.cu
new file mode 100644
index 000000000..25c7179a9
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT16.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_UINT16(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_UINT16 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT16 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< unsigned short >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT32.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT32.cu
new file mode 100644
index 000000000..d180b08ab
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT32.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_UINT32(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_UINT32 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT32 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< unsigned int >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT64.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT64.cu
new file mode 100644
index 000000000..5709e1132
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT64.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_UINT64(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_UINT64 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT64 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< uint64_t >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT8.cu b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT8.cu
new file mode 100644
index 000000000..fb886226a
--- /dev/null
+++ b/cupy/cuda/detail/cupy_thrust_sort_CUPY_TYPE_UINT8.cu
@@ -0,0 +1,27 @@
+#include "../cupy_thrust.inl"
+
+
+namespace cupy {
+
+void thrust_sort_CUPY_TYPE_UINT8(void *data_start,
+                            size_t *keys_start,
+                            const std::vector<ptrdiff_t>& shape,
+                            intptr_t stream,
+                            void* memory) {
+#if ( CUPY_TYPE_UINT8 != CUPY_TYPE_FLOAT16 )                        \
+    || (( CUPY_TYPE_UINT8 == CUPY_TYPE_FLOAT16 )                    \
+        && ((__CUDA_ARCH__ >= 530 || !defined(__CUDA_ARCH__))  \
+            || (defined(__HIPCC__) || defined(CUPY_USE_HIP))))
+
+    _sort op;
+    return dtype_forwarder< unsigned char >(op,
+                                         data_start,
+                                         keys_start,
+                                         shape,
+                                         stream,
+                                         memory);
+
+#endif
+}
+
+}  // namespace cupy
diff --git a/cupy/cuda/detail/generate_translation_units.py b/cupy/cuda/detail/generate_translation_units.py
new file mode 100644
index 000000000..d044eb46c
--- /dev/null
+++ b/cupy/cuda/detail/generate_translation_units.py
@@ -0,0 +1,87 @@
+from typing import List, Mapping, Tuple, Union
+import os
+
+
+def get_cuda_source_data(source_root: str) \
+        -> Mapping[str, Mapping[str, Union[str, Tuple[str, List[str]]]]]:
+    # if not all dtypes are supported, the list of supported dtypes is returned
+    return {
+        'thrust': {
+            'argsort': f'{source_root}/cupy/cuda/detail/cupy_thrust_argsort.template',  # noqa: E501
+            'lexsort': f'{source_root}/cupy/cuda/detail/cupy_thrust_lexsort.template',  # noqa: E501
+            'sort': f'{source_root}/cupy/cuda/detail/cupy_thrust_sort.template',  # noqa: E501
+        },
+        'cub': {
+            'sum': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_sum.template',  # noqa: E501
+            'prod': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_prod.template',  # noqa: E501
+            'min': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_min.template',  # noqa: E501
+            'max': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_max.template',  # noqa: E501
+            'argmin': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_argmin.template',  # noqa: E501
+            'argmax': f'{source_root}/cupy/cuda/detail/cupy_cub_device_reduce_argmax.template',  # noqa: E501
+            's_sum': f'{source_root}/cupy/cuda/detail/cupy_cub_device_segmented_reduce_sum.template',  # noqa: E501
+            's_prod': f'{source_root}/cupy/cuda/detail/cupy_cub_device_segmented_reduce_prod.template',  # noqa: E501
+            's_min': f'{source_root}/cupy/cuda/detail/cupy_cub_device_segmented_reduce_min.template',  # noqa: E501
+            's_max': f'{source_root}/cupy/cuda/detail/cupy_cub_device_segmented_reduce_max.template',  # noqa: E501
+            'cumsum': f'{source_root}/cupy/cuda/detail/cupy_cub_device_scan_cumsum.template',  # noqa: E501
+            'cumprod': f'{source_root}/cupy/cuda/detail/cupy_cub_device_scan_cumprod.template',  # noqa: E501
+            'spmv': f'{source_root}/cupy/cuda/detail/cupy_cub_device_spmv.template',  # noqa: E501
+            'hist_range': (f'{source_root}/cupy/cuda/detail/cupy_cub_device_histogram_range.template',  # noqa: E501
+                           ['char', 'short', 'int', 'int64_t',
+                            'unsigned char', 'unsigned short', 'unsigned int', 'uint64_t',  # noqa: E501
+                            '__half', 'float', 'double',
+                            'bool']),
+            'hist_even': (f'{source_root}/cupy/cuda/detail/cupy_cub_device_histogram_even.template',  # noqa: E501
+                          ['char', 'short', 'int', 'int64_t',
+                           'unsigned char', 'unsigned short', 'unsigned int', 'uint64_t',  # noqa: E501
+                           'bool']),
+        }
+    }
+
+
+# TODO(leofang): use exact bit-width names (ex: int8_t instead of char)
+cuda_type_to_code = {
+    'char': 'CUPY_TYPE_INT8',
+    'short': 'CUPY_TYPE_INT16',
+    'int': 'CUPY_TYPE_INT32',
+    'int64_t': 'CUPY_TYPE_INT64',
+    'unsigned char': 'CUPY_TYPE_UINT8',
+    'unsigned short': 'CUPY_TYPE_UINT16',
+    'unsigned int': 'CUPY_TYPE_UINT32',
+    'uint64_t': 'CUPY_TYPE_UINT64',
+    '__half': 'CUPY_TYPE_FLOAT16',
+    'float': 'CUPY_TYPE_FLOAT32',
+    'double': 'CUPY_TYPE_FLOAT64',
+    'complex<float>': 'CUPY_TYPE_COMPLEX64',
+    'complex<double>': 'CUPY_TYPE_COMPLEX128',
+    'bool': 'CUPY_TYPE_BOOL',
+}
+
+
+def generate_translation_unit(
+        func_name, type_name, code_name, source_path) -> None:
+    with open(source_path) as f:
+        func_template = f.read()
+        func_template = func_template.replace('<CODENAME>', code_name)
+        func_template = func_template.replace('<TYPENAME>', type_name)
+    base_name = os.path.basename(source_path).split('.')[0]
+    full_path = f'{os.path.dirname(source_path)}/{base_name}_{code_name}.cu'
+    with open(full_path, 'w') as f:
+        f.write(func_template)
+    print(f'generated {full_path}')
+
+
+if __name__ == '__main__':
+    source_root = os.path.normpath(
+        os.path.join(os.path.dirname(__file__), '../../..'))
+
+    for mod, funcs in get_cuda_source_data(source_root).items():
+        for func_name, template in funcs.items():
+            if isinstance(template, str):
+                template_path = template
+                supported_types = list(cuda_type_to_code.keys())  # all supported
+            else:
+                template_path, supported_types = template
+            for type_name in supported_types:
+                code_name = cuda_type_to_code[type_name]
+                generate_translation_unit(
+                    func_name, type_name, code_name, template_path)
diff --git a/install/cupy_builder/_command.py b/install/cupy_builder/_command.py
index 5e5934e1b..c93eca47a 100644
--- a/install/cupy_builder/_command.py
+++ b/install/cupy_builder/_command.py
@@ -1,3 +1,4 @@
+import concurrent.futures
 import os
 import sys
 from typing import List, Tuple
@@ -28,40 +29,72 @@ def filter_files_by_extension(
 def compile_device_code(
         ctx: Context,
         ext: setuptools.Extension
-) -> Tuple[List[str], List[str]]:
+) -> List[concurrent.futures.Future]:
     """Compiles device code ("*.cu").
 
     This method invokes the device compiler (nvcc/hipcc) to build object
-    files from device code, then returns the tuple of:
-    - list of remaining (non-device) source files ("*.cpp")
-    - list of compiled object files for device code ("*.o")
+    files from device code, then returns a list of future objects representing
+    nvcc/hipcc compilation tasks.
     """
-    sources_cu, sources_cpp = filter_files_by_extension(
-        ext.sources, '.cu')
+    sources_cpp, sources_cu, objects = get_device_code_objects(ctx, ext)
     if len(sources_cu) == 0:
-        # No device code used in this extension.
-        return ext.sources, []
+        # No device code used in this extension, so no compilation is needed.
+        return []
 
     if sys.platform == 'win32':
         compiler = DeviceCompilerWin32(ctx)
     else:
         compiler = DeviceCompilerUnix(ctx)
 
+    futures = []
+    for src, obj in zip(sources_cu, objects):
+        print(f'{ext.name}: Device code: {src}')
+
+        # We need to look at the timestamps for all depended files.
+        # TODO(leofang): The dependency on *.cu files can be more fine-grained.
+        # Ideally we only need to recompile the changed translation units
+        # independently.
+        if os.path.exists(obj):
+            if ((len(ext.depends) > 0
+                    and all(_get_timestamp(f) < _get_timestamp(obj)
+                            for f in ext.depends))
+                    or (_get_timestamp(src) < _get_timestamp(obj))):
+                print(f'{ext.name}: Reusing cached object file: {obj}')
+                continue
+
+        os.makedirs(os.path.dirname(obj), exist_ok=True)
+        print(f'{ext.name}: Building: {obj}')
+        f = ctx._thread_pool.submit(compiler.compile, obj, src, ext)
+        futures.append(f)
+
+    return futures
+
+
+def get_device_code_objects(
+        ctx: Context,
+        ext: setuptools.Extension
+) -> Tuple[List[str], List[str], List[str]]:
+    """Retrieve the device code ("*.cu") objects.
+
+    Returns:
+        - list of remaining (non-device) source files ("*.cpp")
+        - list of device code files ("*.cu")
+        - list of compiled object files for device code ("*.o")
+    """
+    sources_cu, sources_cpp = filter_files_by_extension(
+        ext.sources, '.cu')
+    if len(sources_cu) == 0:
+        # No device code used in this extension.
+        return ext.sources, [], []
+
     objects = []
     for src in sources_cu:
-        print(f'{ext.name}: Device code: {src}')
         obj_ext = 'obj' if sys.platform == 'win32' else 'o'
         # TODO(kmaehashi): embed CUDA version in path
         obj = f'build/temp.device_objects/{src}.{obj_ext}'
-        if os.path.exists(obj) and (_get_timestamp(src) < _get_timestamp(obj)):
-            print(f'{ext.name}: Reusing cached object file: {obj}')
-        else:
-            os.makedirs(os.path.dirname(obj), exist_ok=True)
-            print(f'{ext.name}: Building: {obj}')
-            compiler.compile(obj, src, ext)
         objects.append(obj)
 
-    return sources_cpp, objects
+    return sources_cpp, sources_cu, objects
 
 
 def _get_timestamp(path: str) -> float:
@@ -73,6 +106,8 @@ class custom_build_ext(setuptools.command.build_ext.build_ext):
 
     """Custom `build_ext` command to include CUDA C source files."""
 
+    _cupy_nvcc_futures: List[concurrent.futures.Future] = []
+
     def build_extensions(self) -> None:
         num_jobs = int(os.environ.get('CUPY_NUM_BUILD_JOBS', '4'))
         if num_jobs > 1:
@@ -91,6 +126,8 @@ class custom_build_ext(setuptools.command.build_ext.build_ext):
         print('Cythonizing...')
         cythonize(self.extensions, cupy_builder.get_context())
 
+        ctx = cupy_builder.get_context()
+
         # Change an extension in each source filenames from "*.pyx" to "*.cpp".
         # c.f. `Cython.Distutils.old_build_ext`
         for ext in self.extensions:
@@ -103,14 +140,28 @@ class custom_build_ext(setuptools.command.build_ext.build_ext):
                 if not os.path.isfile(src):
                     raise RuntimeError(f'Fatal error: missing file: {src}')
 
+            # Compile "*.cu" files into object files. We move this step from
+            # build_extension() to here to simplify the parallel hierachy.
+            self._cupy_nvcc_futures.extend(compile_device_code(ctx, ext))
+
+        # Again, we avoid nvcc & setuptools workers from running in parallel
+        done, _ = concurrent.futures.wait(
+            self._cupy_nvcc_futures,
+            return_when=concurrent.futures.FIRST_EXCEPTION)
+        for future in done:
+            err = future.exception()
+            if err:
+                raise err
+        assert len(done) == len(self._cupy_nvcc_futures)
+
         print('Building extensions...')
         super().build_extensions()
 
     def build_extension(self, ext: setuptools.Extension) -> None:
         ctx = cupy_builder.get_context()
 
-        # Compile "*.cu" files into object files.
-        sources_cpp, extra_objects = compile_device_code(ctx, ext)
+        # Get compiled device code objects for the linker
+        sources_cpp, _, extra_objects = get_device_code_objects(ctx, ext)
 
         # Remove device code from list of sources, and instead add compiled
         # object files to link.
diff --git a/install/cupy_builder/_compiler.py b/install/cupy_builder/_compiler.py
index 84421d524..172fd2d0b 100644
--- a/install/cupy_builder/_compiler.py
+++ b/install/cupy_builder/_compiler.py
@@ -178,7 +178,7 @@ class DeviceCompilerUnix(DeviceCompilerBase):
             postargs += [f'-t{num_threads}']
         else:
             postargs += ['--std=c++11']
-        postargs += ['-Xcompiler=-fno-gnu-unique']
+        postargs += ['-Xcompiler=-fno-gnu-unique', '-Xfatbin=-compress-all']
         print('NVCC options:', postargs)
         self.spawn(compiler_so + base_opts + cc_args + [src, '-o', obj] +
                    postargs)
@@ -217,7 +217,8 @@ class DeviceCompilerWin32(DeviceCompilerBase):
             # to build CuPy because some Python versions were built using it.
             # REF: https://wiki.python.org/moin/WindowsCompilers
             postargs += ['-allow-unsupported-compiler']
-        postargs += ['-Xcompiler', '/MD', '-D_USE_MATH_DEFINES']
+        postargs += ['-Xcompiler', '/MD', '-D_USE_MATH_DEFINES',
+                     '-Xfatbin', '-compress-all']
         # This is to compile thrust with MSVC2015
         if cuda_version >= 11020:
             postargs += ['--std=c++14']
diff --git a/install/cupy_builder/_context.py b/install/cupy_builder/_context.py
index 4da0d4ba3..8530460dc 100644
--- a/install/cupy_builder/_context.py
+++ b/install/cupy_builder/_context.py
@@ -1,7 +1,9 @@
 import argparse
+from concurrent.futures import Executor, ThreadPoolExecutor
+import glob
 import os
 import sys
-from typing import Any, List, Mapping, Optional, Tuple
+from typing import Any, Dict, List, Mapping, Optional, Tuple
 
 
 def _get_env_bool(name: str, default: bool, env: Mapping[str, str]) -> bool:
@@ -37,6 +39,21 @@ class Context:
         if os.environ.get('READTHEDOCS', None) == 'True':
             self.use_stub = True
 
+        self.module_TUs: Dict[str, List[str]] = {}
+        self._thread_pool: Executor = ThreadPoolExecutor(
+            max_workers=int(os.environ.get('CUPY_NUM_BUILD_JOBS', '4')),
+            thread_name_prefix='cupy_nvcc_worker_',
+        )
+        self._fetch_translation_units()
+
+    def _fetch_translation_units(self) -> None:
+        module_TUs = self.module_TUs
+        # The files are pre-generated via a separate script and checked in
+        # to the repo
+        TUs = glob.glob('./cupy/cuda/detail/*.cu')
+        for mod in ('thrust', 'cub'):
+            module_TUs[mod] = [TU for TU in TUs if mod in TU]
+
 
 def parse_args(argv: List[str]) -> Tuple[Any, List[str]]:
     parser = argparse.ArgumentParser(add_help=False)
diff --git a/install/cupy_builder/cupy_setup_build.py b/install/cupy_builder/cupy_setup_build.py
index 966ec7079..bb851ba91 100644
--- a/install/cupy_builder/cupy_setup_build.py
+++ b/install/cupy_builder/cupy_setup_build.py
@@ -3,6 +3,7 @@
 import copy
 from distutils import ccompiler
 from distutils import sysconfig
+import glob
 import os
 import shutil
 import sys
@@ -334,6 +335,20 @@ def make_extensions(ctx: Context, compiler, use_cython):
             if compiler.compiler_type == 'msvc':
                 compile_args.append('-D_USE_MATH_DEFINES')
 
+        if module['name'] in ('thrust', 'cub'):
+            # TODO(leofang): make "depends" aware of CUPY_NVCC_GENERATE_CODE
+            # TODO(leofang): include all the cupy headers here?
+            mod_name = module['name']
+            assert module['file'][0][0] == f'cupy.cuda.{mod_name}'
+            module['file'][0][1].extend(ctx.module_TUs[mod_name])
+            s['depends'] = [
+                f'./cupy/cuda/cupy_{mod_name}.h',
+                f'./cupy/cuda/cupy_{mod_name}.inl',
+            ] + [
+                x for x in glob.glob(f'./cupy/cuda/detail/cupy_{mod_name}*.cu')
+                if os.path.isfile(x)
+            ]
+
         if module['name'] == 'jitify':
             # this fixes RTD (no_cuda) builds...
             compile_args.append('--std=c++11')
diff --git a/setup.py b/setup.py
index 422e9ebde..c75095a8c 100644
--- a/setup.py
+++ b/setup.py
@@ -69,6 +69,12 @@ cupy_package_data = [
     if os.path.isfile(x)
 ]
 
+
+# Generated translation units
+for _, files in ctx.module_TUs.items():
+    cupy_package_data.extend(files)
+
+
 package_data = {
     'cupy': [
         os.path.relpath(x, 'cupy') for x in cupy_package_data
